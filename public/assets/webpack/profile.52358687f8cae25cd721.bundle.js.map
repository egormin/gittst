{"version":3,"sources":["webpack:///profile.52358687f8cae25cd721.bundle.js","webpack:////var/cache/omnibus/src/gitlab-rails/vendor/assets/javascripts/cropper.js","webpack:///./profile/gl_crop.js","webpack:///./profile/profile.js"],"names":["webpackJsonp","../../../vendor/assets/javascripts/cropper.js","module","exports","__webpack_require__","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","undefined","apply","$","isNumber","n","isNaN","isUndefined","toArray","obj","offset","args","push","slice","proxy","fn","context","arguments","concat","isCrossOriginURL","url","parts","match","location","protocol","hostname","port","addTimestamp","timestamp","Date","getTime","indexOf","getCrossOrigin","crossOrigin","getImageSize","image","callback","newImage","naturalWidth","IS_SAFARI","naturalHeight","document","createElement","onload","this","width","height","src","getTransform","options","transforms","rotate","scaleX","scaleY","length","join","getRotatedSizes","data","isReversed","newWidth","newHeight","deg","abs","degree","arc","Math","PI","sinArc","sin","cosArc","cos","aspectRatio","getSourceCanvas","translateX","translateY","rotated","canvas","getContext","dstX","dstY","dstWidth","dstHeight","scalable","rotatable","advanced","canvasWidth","canvasHeight","save","translate","scale","drawImage","floor","restore","getTouchesCenter","touches","pageX","pageY","each","i","touch","getStringFromCharCode","dataView","start","str","fromCharCode","getUint8","getOrientation","arrayBuffer","orientation","exifIDCode","tiffOffset","firstIFDOffset","littleEndian","endianness","app1Start","ifdStart","DataView","byteLength","getUint16","getUint32","setUint16","dataURLToArrayBuffer","dataURL","base64","replace","REGEXP_DATA_URL_HEAD","binary","atob","ArrayBuffer","Uint8Array","charCodeAt","arrayBufferToDataURL","btoa","Cropper","element","$element","extend","DEFAULTS","isPlainObject","isLoaded","isBuilt","isCompleted","isRotated","isCropped","isDisabled","isReplaced","isLimited","wheeling","isImg","originalUrl","cropBox","init","$window","window","$document","navigator","CLASS_HIDDEN","EVENT_MOUSE_UP","REGEXP_ACTIONS","REGEXP_DATA_URL","REGEXP_DATA_URL_JPEG","SUPPORT_CANVAS","isFunction","test","userAgent","vendor","num","Number","min","max","sqrt","round","String","prototype","constructor","$this","is","attr","prop","toDataURL","load","trigger","type","e","Event","read","xhr","one","build","isDefaultPrevented","checkOrientation","clone","XMLHttpRequest","onerror","onabort","response","open","responseType","send","crossOriginUrl","$clone","checkCrossOrigin","complete","stop","addClass","insertAfter","$image","off","remove","$cropper","$cropBox","$face","unbuild","$container","parent","TEMPLATE","$canvas","find","append","$dragBox","$viewBox","after","removeClass","initPreview","bind","NaN","viewMode","autoCrop","modal","guides","center","cropBoxMovable","highlight","background","cropBoxResizable","setDragMode","dragMode","render","setData","built","setTimeout","initialImage","initialCanvas","initialCropBox","container","unbind","resetPreview","$preview","initContainer","initCanvas","initCropBox","renderCanvas","renderCropBox","css","minContainerWidth","minContainerHeight","containerWidth","containerHeight","imageNaturalWidth","imageNaturalHeight","is90Degree","oldLeft","left","oldTop","top","limitCanvas","isSizeLimited","isPositionLimited","minCanvasWidth","minCanvasHeight","newCanvasLeft","newCanvasTop","minWidth","minHeight","maxWidth","Infinity","maxHeight","minLeft","minTop","maxLeft","maxTop","isChanged","renderImage","limitCropBox","output","reversed","marginLeft","marginTop","transform","autoCropArea","minCropBoxWidth","minCropBoxHeight","maxCropBoxWidth","maxCropBoxHeight","movable","preview","getData","$clone2","html","removeData","cropBoxWidth","cropBoxHeight","originalWidth","originalHeight","ratio","cropstart","on","cropmove","cropend","crop","zoom","cropStart","zoomable","zoomOnWheel","wheel","toggleDragModeOnDblclick","dblclick","_cropMove","cropMove","_cropEnd","cropEnd","responsive","_resize","resize","canvasData","cropBoxData","getCanvasData","getCropBoxData","setCanvasData","setCropBoxData","hasClass","event","originalEvent","wheelZoomRatio","delta","preventDefault","deltaY","wheelDelta","detail","touchesLength","action","zoomOnTouch","startX2","startY2","target","cropping","startX","startY","endX2","endY2","endX","endY","change","shiftKey","toggleClass","range","right","bottom","renderable","limited","x","y","X","Y","move","x1","y1","x2","y2","z1","reset","clear","onlyColorChanged","add","enable","disable","destroy","offsetX","offsetY","moveTo","_event","zoomTo","oldRatio","rotateTo","isRounded","isScaled","call","getContainerData","getImageData","isWidthChanged","isHeightChanged","getCroppedCanvas","scaledWidth","scaledHeight","scaledRatio","fillColor","fillStyle","fillRect","srcWidth","srcHeight","source","sourceWidth","sourceHeight","params","srcX","srcY","setAspectRatio","mode","croppable","setDefaults","other","cropper","option","result","Constructor","noConflict","./profile/gl_crop.js","__webpack_exports__","_classCallCheck","instance","TypeError","__WEBPACK_IMPORTED_MODULE_0_vendor_cropper__","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","global","FILENAMEREGEX","GitLabCrop","input","_ref","filename","previewImage","modalCrop","pickImageEl","uploadImageBtn","modalCropImg","_ref$exportWidth","exportWidth","_ref$exportHeight","exportHeight","_ref$cropBoxWidth","_ref$cropBoxHeight","onUploadImageBtnClick","onModalHide","onModalShow","onPickImageClick","fileInput","_","isString","form","parents","getElement","cropActionsBtn","bindEvents","value","selector","_this","onFileInputChange","btn","onActionBtnClick","croppedImageBlob","setBlob","setPreview","val","method","readFile","reader","FileReader","readAsDataURL","files","array","k","len","split","Blob","text","dataURLtoBlob","glCrop","opts","gl","./profile/profile.js","Profile","onSubmitForm","initAvatarGlCrop","cropOpts","avatarGlCrop","submitForm","beforeUpdateUsername","afterUpdateUsername","onUpdateNotifs","submit","saveForm","saved","Flash","self","formData","FormData","avatarBlob","getBlob","ajax","dataType","processData","contentType","success","message","error","jqXHR","responseJSON","scrollTo","$title","comment","utils","getPagePath","./profile/profile_bundle.js","__WEBPACK_IMPORTED_MODULE_1__profile__"],"mappings":"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","file":"profile.52358687f8cae25cd721.bundle.js","sourcesContent":["webpackJsonp([\"profile\"],{\n\n/***/ \"../../../vendor/assets/javascripts/cropper.js\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Cropper v2.3.0\n * https://github.com/fengyuanchen/cropper\n *\n * Copyright (c) 2014-2016 Fengyuan Chen and contributors\n * Released under the MIT license\n *\n * Date: 2016-02-22T02:13:13.332Z\n */\n\n(function (factory) {\n  if (true) {\n    // AMD. Register as anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"../../../node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof exports === 'object') {\n    // Node / CommonJS\n    factory(require('jquery'));\n  } else {\n    // Browser globals.\n    factory(jQuery);\n  }\n})(function ($) {\n\n  'use strict';\n\n  // Globals\n  var $window = $(window);\n  var $document = $(document);\n  var location = window.location;\n  var navigator = window.navigator;\n  var ArrayBuffer = window.ArrayBuffer;\n  var Uint8Array = window.Uint8Array;\n  var DataView = window.DataView;\n  var btoa = window.btoa;\n\n  // Constants\n  var NAMESPACE = 'cropper';\n\n  // Classes\n  var CLASS_MODAL = 'cropper-modal';\n  var CLASS_HIDE = 'cropper-hide';\n  var CLASS_HIDDEN = 'cropper-hidden';\n  var CLASS_INVISIBLE = 'cropper-invisible';\n  var CLASS_MOVE = 'cropper-move';\n  var CLASS_CROP = 'cropper-crop';\n  var CLASS_DISABLED = 'cropper-disabled';\n  var CLASS_BG = 'cropper-bg';\n\n  // Events\n  var EVENT_MOUSE_DOWN = 'mousedown touchstart pointerdown MSPointerDown';\n  var EVENT_MOUSE_MOVE = 'mousemove touchmove pointermove MSPointerMove';\n  var EVENT_MOUSE_UP = 'mouseup touchend touchcancel pointerup pointercancel MSPointerUp MSPointerCancel';\n  var EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';\n  var EVENT_DBLCLICK = 'dblclick';\n  var EVENT_LOAD = 'load.' + NAMESPACE;\n  var EVENT_ERROR = 'error.' + NAMESPACE;\n  var EVENT_RESIZE = 'resize.' + NAMESPACE; // Bind to window with namespace\n  var EVENT_BUILD = 'build.' + NAMESPACE;\n  var EVENT_BUILT = 'built.' + NAMESPACE;\n  var EVENT_CROP_START = 'cropstart.' + NAMESPACE;\n  var EVENT_CROP_MOVE = 'cropmove.' + NAMESPACE;\n  var EVENT_CROP_END = 'cropend.' + NAMESPACE;\n  var EVENT_CROP = 'crop.' + NAMESPACE;\n  var EVENT_ZOOM = 'zoom.' + NAMESPACE;\n\n  // RegExps\n  var REGEXP_ACTIONS = /e|w|s|n|se|sw|ne|nw|all|crop|move|zoom/;\n  var REGEXP_DATA_URL = /^data\\:/;\n  var REGEXP_DATA_URL_HEAD = /^data\\:([^\\;]+)\\;base64,/;\n  var REGEXP_DATA_URL_JPEG = /^data\\:image\\/jpeg.*;base64,/;\n\n  // Data keys\n  var DATA_PREVIEW = 'preview';\n  var DATA_ACTION = 'action';\n\n  // Actions\n  var ACTION_EAST = 'e';\n  var ACTION_WEST = 'w';\n  var ACTION_SOUTH = 's';\n  var ACTION_NORTH = 'n';\n  var ACTION_SOUTH_EAST = 'se';\n  var ACTION_SOUTH_WEST = 'sw';\n  var ACTION_NORTH_EAST = 'ne';\n  var ACTION_NORTH_WEST = 'nw';\n  var ACTION_ALL = 'all';\n  var ACTION_CROP = 'crop';\n  var ACTION_MOVE = 'move';\n  var ACTION_ZOOM = 'zoom';\n  var ACTION_NONE = 'none';\n\n  // Supports\n  var SUPPORT_CANVAS = $.isFunction($('<canvas>')[0].getContext);\n  var IS_SAFARI = navigator && /safari/i.test(navigator.userAgent) && /apple computer/i.test(navigator.vendor);\n\n  // Maths\n  var num = Number;\n  var min = Math.min;\n  var max = Math.max;\n  var abs = Math.abs;\n  var sin = Math.sin;\n  var cos = Math.cos;\n  var sqrt = Math.sqrt;\n  var round = Math.round;\n  var floor = Math.floor;\n\n  // Utilities\n  var fromCharCode = String.fromCharCode;\n\n  function isNumber(n) {\n    return typeof n === 'number' && !isNaN(n);\n  }\n\n  function isUndefined(n) {\n    return typeof n === 'undefined';\n  }\n\n  function toArray(obj, offset) {\n    var args = [];\n\n    // This is necessary for IE8\n    if (isNumber(offset)) {\n      args.push(offset);\n    }\n\n    return args.slice.apply(obj, args);\n  }\n\n  // Custom proxy to avoid jQuery's guid\n  function proxy(fn, context) {\n    var args = toArray(arguments, 2);\n\n    return function () {\n      return fn.apply(context, args.concat(toArray(arguments)));\n    };\n  }\n\n  function isCrossOriginURL(url) {\n    var parts = url.match(/^(https?:)\\/\\/([^\\:\\/\\?#]+):?(\\d*)/i);\n\n    return parts && (\n      parts[1] !== location.protocol ||\n      parts[2] !== location.hostname ||\n      parts[3] !== location.port\n    );\n  }\n\n  function addTimestamp(url) {\n    var timestamp = 'timestamp=' + (new Date()).getTime();\n\n    return (url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp);\n  }\n\n  function getCrossOrigin(crossOrigin) {\n    return crossOrigin ? ' crossOrigin=\"' + crossOrigin + '\"' : '';\n  }\n\n  function getImageSize(image, callback) {\n    var newImage;\n\n    // Modern browsers (ignore Safari, #120 & #509)\n    if (image.naturalWidth && !IS_SAFARI) {\n      return callback(image.naturalWidth, image.naturalHeight);\n    }\n\n    // IE8: Don't use `new Image()` here (#319)\n    newImage = document.createElement('img');\n\n    newImage.onload = function () {\n      callback(this.width, this.height);\n    };\n\n    newImage.src = image.src;\n  }\n\n  function getTransform(options) {\n    var transforms = [];\n    var rotate = options.rotate;\n    var scaleX = options.scaleX;\n    var scaleY = options.scaleY;\n\n    if (isNumber(rotate)) {\n      transforms.push('rotate(' + rotate + 'deg)');\n    }\n\n    if (isNumber(scaleX) && isNumber(scaleY)) {\n      transforms.push('scale(' + scaleX + ',' + scaleY + ')');\n    }\n\n    return transforms.length ? transforms.join(' ') : 'none';\n  }\n\n  function getRotatedSizes(data, isReversed) {\n    var deg = abs(data.degree) % 180;\n    var arc = (deg > 90 ? (180 - deg) : deg) * Math.PI / 180;\n    var sinArc = sin(arc);\n    var cosArc = cos(arc);\n    var width = data.width;\n    var height = data.height;\n    var aspectRatio = data.aspectRatio;\n    var newWidth;\n    var newHeight;\n\n    if (!isReversed) {\n      newWidth = width * cosArc + height * sinArc;\n      newHeight = width * sinArc + height * cosArc;\n    } else {\n      newWidth = width / (cosArc + sinArc / aspectRatio);\n      newHeight = newWidth / aspectRatio;\n    }\n\n    return {\n      width: newWidth,\n      height: newHeight\n    };\n  }\n\n  function getSourceCanvas(image, data) {\n    var canvas = $('<canvas>')[0];\n    var context = canvas.getContext('2d');\n    var dstX = 0;\n    var dstY = 0;\n    var dstWidth = data.naturalWidth;\n    var dstHeight = data.naturalHeight;\n    var rotate = data.rotate;\n    var scaleX = data.scaleX;\n    var scaleY = data.scaleY;\n    var scalable = isNumber(scaleX) && isNumber(scaleY) && (scaleX !== 1 || scaleY !== 1);\n    var rotatable = isNumber(rotate) && rotate !== 0;\n    var advanced = rotatable || scalable;\n    var canvasWidth = dstWidth * abs(scaleX || 1);\n    var canvasHeight = dstHeight * abs(scaleY || 1);\n    var translateX;\n    var translateY;\n    var rotated;\n\n    if (scalable) {\n      translateX = canvasWidth / 2;\n      translateY = canvasHeight / 2;\n    }\n\n    if (rotatable) {\n      rotated = getRotatedSizes({\n        width: canvasWidth,\n        height: canvasHeight,\n        degree: rotate\n      });\n\n      canvasWidth = rotated.width;\n      canvasHeight = rotated.height;\n      translateX = canvasWidth / 2;\n      translateY = canvasHeight / 2;\n    }\n\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n\n    if (advanced) {\n      dstX = -dstWidth / 2;\n      dstY = -dstHeight / 2;\n\n      context.save();\n      context.translate(translateX, translateY);\n    }\n\n    if (rotatable) {\n      context.rotate(rotate * Math.PI / 180);\n    }\n\n    // Should call `scale` after rotated\n    if (scalable) {\n      context.scale(scaleX, scaleY);\n    }\n\n    context.drawImage(image, floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));\n\n    if (advanced) {\n      context.restore();\n    }\n\n    return canvas;\n  }\n\n  function getTouchesCenter(touches) {\n    var length = touches.length;\n    var pageX = 0;\n    var pageY = 0;\n\n    if (length) {\n      $.each(touches, function (i, touch) {\n        pageX += touch.pageX;\n        pageY += touch.pageY;\n      });\n\n      pageX /= length;\n      pageY /= length;\n    }\n\n    return {\n      pageX: pageX,\n      pageY: pageY\n    };\n  }\n\n  function getStringFromCharCode(dataView, start, length) {\n    var str = '';\n    var i;\n\n    for (i = start, length += start; i < length; i++) {\n      str += fromCharCode(dataView.getUint8(i));\n    }\n\n    return str;\n  }\n\n  function getOrientation(arrayBuffer) {\n    var dataView = new DataView(arrayBuffer);\n    var length = dataView.byteLength;\n    var orientation;\n    var exifIDCode;\n    var tiffOffset;\n    var firstIFDOffset;\n    var littleEndian;\n    var endianness;\n    var app1Start;\n    var ifdStart;\n    var offset;\n    var i;\n\n    // Only handle JPEG image (start by 0xFFD8)\n    if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\n      offset = 2;\n\n      while (offset < length) {\n        if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\n          app1Start = offset;\n          break;\n        }\n\n        offset++;\n      }\n    }\n\n    if (app1Start) {\n      exifIDCode = app1Start + 4;\n      tiffOffset = app1Start + 10;\n\n      if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\n        endianness = dataView.getUint16(tiffOffset);\n        littleEndian = endianness === 0x4949;\n\n        if (littleEndian || endianness === 0x4D4D /* bigEndian */) {\n          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\n            firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n\n            if (firstIFDOffset >= 0x00000008) {\n              ifdStart = tiffOffset + firstIFDOffset;\n            }\n          }\n        }\n      }\n    }\n\n    if (ifdStart) {\n      length = dataView.getUint16(ifdStart, littleEndian);\n\n      for (i = 0; i < length; i++) {\n        offset = ifdStart + i * 12 + 2;\n\n        if (dataView.getUint16(offset, littleEndian) === 0x0112 /* Orientation */) {\n\n          // 8 is the offset of the current tag's value\n          offset += 8;\n\n          // Get the original orientation value\n          orientation = dataView.getUint16(offset, littleEndian);\n\n          // Override the orientation with its default value for Safari (#120)\n          if (IS_SAFARI) {\n            dataView.setUint16(offset, 1, littleEndian);\n          }\n\n          break;\n        }\n      }\n    }\n\n    return orientation;\n  }\n\n  function dataURLToArrayBuffer(dataURL) {\n    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');\n    var binary = atob(base64);\n    var length = binary.length;\n    var arrayBuffer = new ArrayBuffer(length);\n    var dataView = new Uint8Array(arrayBuffer);\n    var i;\n\n    for (i = 0; i < length; i++) {\n      dataView[i] = binary.charCodeAt(i);\n    }\n\n    return arrayBuffer;\n  }\n\n  // Only available for JPEG image\n  function arrayBufferToDataURL(arrayBuffer) {\n    var dataView = new Uint8Array(arrayBuffer);\n    var length = dataView.length;\n    var base64 = '';\n    var i;\n\n    for (i = 0; i < length; i++) {\n      base64 += fromCharCode(dataView[i]);\n    }\n\n    return 'data:image/jpeg;base64,' + btoa(base64);\n  }\n\n  function Cropper(element, options) {\n    this.$element = $(element);\n    this.options = $.extend({}, Cropper.DEFAULTS, $.isPlainObject(options) && options);\n    this.isLoaded = false;\n    this.isBuilt = false;\n    this.isCompleted = false;\n    this.isRotated = false;\n    this.isCropped = false;\n    this.isDisabled = false;\n    this.isReplaced = false;\n    this.isLimited = false;\n    this.wheeling = false;\n    this.isImg = false;\n    this.originalUrl = '';\n    this.canvas = null;\n    this.cropBox = null;\n    this.init();\n  }\n\n  Cropper.prototype = {\n    constructor: Cropper,\n\n    init: function () {\n      var $this = this.$element;\n      var url;\n\n      if ($this.is('img')) {\n        this.isImg = true;\n\n        // Should use `$.fn.attr` here. e.g.: \"img/picture.jpg\"\n        this.originalUrl = url = $this.attr('src');\n\n        // Stop when it's a blank image\n        if (!url) {\n          return;\n        }\n\n        // Should use `$.fn.prop` here. e.g.: \"http://example.com/img/picture.jpg\"\n        url = $this.prop('src');\n      } else if ($this.is('canvas') && SUPPORT_CANVAS) {\n        url = $this[0].toDataURL();\n      }\n\n      this.load(url);\n    },\n\n    // A shortcut for triggering custom events\n    trigger: function (type, data) {\n      var e = $.Event(type, data);\n\n      this.$element.trigger(e);\n\n      return e;\n    },\n\n    load: function (url) {\n      var options = this.options;\n      var $this = this.$element;\n      var read;\n      var xhr;\n\n      if (!url) {\n        return;\n      }\n\n      // Trigger build event first\n      $this.one(EVENT_BUILD, options.build);\n\n      if (this.trigger(EVENT_BUILD).isDefaultPrevented()) {\n        return;\n      }\n\n      this.url = url;\n      this.image = {};\n\n      if (!options.checkOrientation || !ArrayBuffer) {\n        return this.clone();\n      }\n\n      read = $.proxy(this.read, this);\n\n      // XMLHttpRequest disallows to open a Data URL in some browsers like IE11 and Safari\n      if (REGEXP_DATA_URL.test(url)) {\n        return REGEXP_DATA_URL_JPEG.test(url) ?\n          read(dataURLToArrayBuffer(url)) :\n          this.clone();\n      }\n\n      xhr = new XMLHttpRequest();\n\n      xhr.onerror = xhr.onabort = $.proxy(function () {\n        this.clone();\n      }, this);\n\n      xhr.onload = function () {\n        read(this.response);\n      };\n\n      xhr.open('get', url);\n      xhr.responseType = 'arraybuffer';\n      xhr.send();\n    },\n\n    read: function (arrayBuffer) {\n      var options = this.options;\n      var orientation = getOrientation(arrayBuffer);\n      var image = this.image;\n      var rotate;\n      var scaleX;\n      var scaleY;\n\n      if (orientation > 1) {\n        this.url = arrayBufferToDataURL(arrayBuffer);\n\n        switch (orientation) {\n\n          // flip horizontal\n          case 2:\n            scaleX = -1;\n            break;\n\n          // rotate left 180\n          case 3:\n            rotate = -180;\n            break;\n\n          // flip vertical\n          case 4:\n            scaleY = -1;\n            break;\n\n          // flip vertical + rotate right 90\n          case 5:\n            rotate = 90;\n            scaleY = -1;\n            break;\n\n          // rotate right 90\n          case 6:\n            rotate = 90;\n            break;\n\n          // flip horizontal + rotate right 90\n          case 7:\n            rotate = 90;\n            scaleX = -1;\n            break;\n\n          // rotate left 90\n          case 8:\n            rotate = -90;\n            break;\n        }\n      }\n\n      if (options.rotatable) {\n        image.rotate = rotate;\n      }\n\n      if (options.scalable) {\n        image.scaleX = scaleX;\n        image.scaleY = scaleY;\n      }\n\n      this.clone();\n    },\n\n    clone: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var url = this.url;\n      var crossOrigin = '';\n      var crossOriginUrl;\n      var $clone;\n\n      if (options.checkCrossOrigin && isCrossOriginURL(url)) {\n        crossOrigin = $this.prop('crossOrigin');\n\n        if (crossOrigin) {\n          crossOriginUrl = url;\n        } else {\n          crossOrigin = 'anonymous';\n\n          // Bust cache (#148) when there is not a \"crossOrigin\" property\n          crossOriginUrl = addTimestamp(url);\n        }\n      }\n\n      this.crossOrigin = crossOrigin;\n      this.crossOriginUrl = crossOriginUrl;\n      this.$clone = $clone = $('<img' + getCrossOrigin(crossOrigin) + ' src=\"' + (crossOriginUrl || url) + '\">');\n\n      if (this.isImg) {\n        if ($this[0].complete) {\n          this.start();\n        } else {\n          $this.one(EVENT_LOAD, $.proxy(this.start, this));\n        }\n      } else {\n        $clone.\n          one(EVENT_LOAD, $.proxy(this.start, this)).\n          one(EVENT_ERROR, $.proxy(this.stop, this)).\n          addClass(CLASS_HIDE).\n          insertAfter($this);\n      }\n    },\n\n    start: function () {\n      var $image = this.$element;\n      var $clone = this.$clone;\n\n      if (!this.isImg) {\n        $clone.off(EVENT_ERROR, this.stop);\n        $image = $clone;\n      }\n\n      getImageSize($image[0], $.proxy(function (naturalWidth, naturalHeight) {\n        $.extend(this.image, {\n          naturalWidth: naturalWidth,\n          naturalHeight: naturalHeight,\n          aspectRatio: naturalWidth / naturalHeight\n        });\n\n        this.isLoaded = true;\n        this.build();\n      }, this));\n    },\n\n    stop: function () {\n      this.$clone.remove();\n      this.$clone = null;\n    },\n\n    build: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $clone = this.$clone;\n      var $cropper;\n      var $cropBox;\n      var $face;\n\n      if (!this.isLoaded) {\n        return;\n      }\n\n      // Unbuild first when replace\n      if (this.isBuilt) {\n        this.unbuild();\n      }\n\n      // Create cropper elements\n      this.$container = $this.parent();\n      this.$cropper = $cropper = $(Cropper.TEMPLATE);\n      this.$canvas = $cropper.find('.cropper-canvas').append($clone);\n      this.$dragBox = $cropper.find('.cropper-drag-box');\n      this.$cropBox = $cropBox = $cropper.find('.cropper-crop-box');\n      this.$viewBox = $cropper.find('.cropper-view-box');\n      this.$face = $face = $cropBox.find('.cropper-face');\n\n      // Hide the original image\n      $this.addClass(CLASS_HIDDEN).after($cropper);\n\n      // Show the clone image if is hidden\n      if (!this.isImg) {\n        $clone.removeClass(CLASS_HIDE);\n      }\n\n      this.initPreview();\n      this.bind();\n\n      options.aspectRatio = max(0, options.aspectRatio) || NaN;\n      options.viewMode = max(0, min(3, round(options.viewMode))) || 0;\n\n      if (options.autoCrop) {\n        this.isCropped = true;\n\n        if (options.modal) {\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n      } else {\n        $cropBox.addClass(CLASS_HIDDEN);\n      }\n\n      if (!options.guides) {\n        $cropBox.find('.cropper-dashed').addClass(CLASS_HIDDEN);\n      }\n\n      if (!options.center) {\n        $cropBox.find('.cropper-center').addClass(CLASS_HIDDEN);\n      }\n\n      if (options.cropBoxMovable) {\n        $face.addClass(CLASS_MOVE).data(DATA_ACTION, ACTION_ALL);\n      }\n\n      if (!options.highlight) {\n        $face.addClass(CLASS_INVISIBLE);\n      }\n\n      if (options.background) {\n        $cropper.addClass(CLASS_BG);\n      }\n\n      if (!options.cropBoxResizable) {\n        $cropBox.find('.cropper-line, .cropper-point').addClass(CLASS_HIDDEN);\n      }\n\n      this.setDragMode(options.dragMode);\n      this.render();\n      this.isBuilt = true;\n      this.setData(options.data);\n      $this.one(EVENT_BUILT, options.built);\n\n      // Trigger the built event asynchronously to keep `data('cropper')` is defined\n      setTimeout($.proxy(function () {\n        this.trigger(EVENT_BUILT);\n        this.isCompleted = true;\n      }, this), 0);\n    },\n\n    unbuild: function () {\n      if (!this.isBuilt) {\n        return;\n      }\n\n      this.isBuilt = false;\n      this.isCompleted = false;\n      this.initialImage = null;\n\n      // Clear `initialCanvas` is necessary when replace\n      this.initialCanvas = null;\n      this.initialCropBox = null;\n      this.container = null;\n      this.canvas = null;\n\n      // Clear `cropBox` is necessary when replace\n      this.cropBox = null;\n      this.unbind();\n\n      this.resetPreview();\n      this.$preview = null;\n\n      this.$viewBox = null;\n      this.$cropBox = null;\n      this.$dragBox = null;\n      this.$canvas = null;\n      this.$container = null;\n\n      this.$cropper.remove();\n      this.$cropper = null;\n    },\n\n    render: function () {\n      this.initContainer();\n      this.initCanvas();\n      this.initCropBox();\n\n      this.renderCanvas();\n\n      if (this.isCropped) {\n        this.renderCropBox();\n      }\n    },\n\n    initContainer: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $container = this.$container;\n      var $cropper = this.$cropper;\n\n      $cropper.addClass(CLASS_HIDDEN);\n      $this.removeClass(CLASS_HIDDEN);\n\n      $cropper.css((this.container = {\n        width: max($container.width(), num(options.minContainerWidth) || 200),\n        height: max($container.height(), num(options.minContainerHeight) || 100)\n      }));\n\n      $this.addClass(CLASS_HIDDEN);\n      $cropper.removeClass(CLASS_HIDDEN);\n    },\n\n    // Canvas (image wrapper)\n    initCanvas: function () {\n      var viewMode = this.options.viewMode;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var image = this.image;\n      var imageNaturalWidth = image.naturalWidth;\n      var imageNaturalHeight = image.naturalHeight;\n      var is90Degree = abs(image.rotate) === 90;\n      var naturalWidth = is90Degree ? imageNaturalHeight : imageNaturalWidth;\n      var naturalHeight = is90Degree ? imageNaturalWidth : imageNaturalHeight;\n      var aspectRatio = naturalWidth / naturalHeight;\n      var canvasWidth = containerWidth;\n      var canvasHeight = containerHeight;\n      var canvas;\n\n      if (containerHeight * aspectRatio > containerWidth) {\n        if (viewMode === 3) {\n          canvasWidth = containerHeight * aspectRatio;\n        } else {\n          canvasHeight = containerWidth / aspectRatio;\n        }\n      } else {\n        if (viewMode === 3) {\n          canvasHeight = containerWidth / aspectRatio;\n        } else {\n          canvasWidth = containerHeight * aspectRatio;\n        }\n      }\n\n      canvas = {\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight,\n        aspectRatio: aspectRatio,\n        width: canvasWidth,\n        height: canvasHeight\n      };\n\n      canvas.oldLeft = canvas.left = (containerWidth - canvasWidth) / 2;\n      canvas.oldTop = canvas.top = (containerHeight - canvasHeight) / 2;\n\n      this.canvas = canvas;\n      this.isLimited = (viewMode === 1 || viewMode === 2);\n      this.limitCanvas(true, true);\n      this.initialImage = $.extend({}, image);\n      this.initialCanvas = $.extend({}, canvas);\n    },\n\n    limitCanvas: function (isSizeLimited, isPositionLimited) {\n      var options = this.options;\n      var viewMode = options.viewMode;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var canvas = this.canvas;\n      var aspectRatio = canvas.aspectRatio;\n      var cropBox = this.cropBox;\n      var isCropped = this.isCropped && cropBox;\n      var minCanvasWidth;\n      var minCanvasHeight;\n      var newCanvasLeft;\n      var newCanvasTop;\n\n      if (isSizeLimited) {\n        minCanvasWidth = num(options.minCanvasWidth) || 0;\n        minCanvasHeight = num(options.minCanvasHeight) || 0;\n\n        if (viewMode) {\n          if (viewMode > 1) {\n            minCanvasWidth = max(minCanvasWidth, containerWidth);\n            minCanvasHeight = max(minCanvasHeight, containerHeight);\n\n            if (viewMode === 3) {\n              if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                minCanvasWidth = minCanvasHeight * aspectRatio;\n              } else {\n                minCanvasHeight = minCanvasWidth / aspectRatio;\n              }\n            }\n          } else {\n            if (minCanvasWidth) {\n              minCanvasWidth = max(minCanvasWidth, isCropped ? cropBox.width : 0);\n            } else if (minCanvasHeight) {\n              minCanvasHeight = max(minCanvasHeight, isCropped ? cropBox.height : 0);\n            } else if (isCropped) {\n              minCanvasWidth = cropBox.width;\n              minCanvasHeight = cropBox.height;\n\n              if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                minCanvasWidth = minCanvasHeight * aspectRatio;\n              } else {\n                minCanvasHeight = minCanvasWidth / aspectRatio;\n              }\n            }\n          }\n        }\n\n        if (minCanvasWidth && minCanvasHeight) {\n          if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n            minCanvasHeight = minCanvasWidth / aspectRatio;\n          } else {\n            minCanvasWidth = minCanvasHeight * aspectRatio;\n          }\n        } else if (minCanvasWidth) {\n          minCanvasHeight = minCanvasWidth / aspectRatio;\n        } else if (minCanvasHeight) {\n          minCanvasWidth = minCanvasHeight * aspectRatio;\n        }\n\n        canvas.minWidth = minCanvasWidth;\n        canvas.minHeight = minCanvasHeight;\n        canvas.maxWidth = Infinity;\n        canvas.maxHeight = Infinity;\n      }\n\n      if (isPositionLimited) {\n        if (viewMode) {\n          newCanvasLeft = containerWidth - canvas.width;\n          newCanvasTop = containerHeight - canvas.height;\n\n          canvas.minLeft = min(0, newCanvasLeft);\n          canvas.minTop = min(0, newCanvasTop);\n          canvas.maxLeft = max(0, newCanvasLeft);\n          canvas.maxTop = max(0, newCanvasTop);\n\n          if (isCropped && this.isLimited) {\n            canvas.minLeft = min(\n              cropBox.left,\n              cropBox.left + cropBox.width - canvas.width\n            );\n            canvas.minTop = min(\n              cropBox.top,\n              cropBox.top + cropBox.height - canvas.height\n            );\n            canvas.maxLeft = cropBox.left;\n            canvas.maxTop = cropBox.top;\n\n            if (viewMode === 2) {\n              if (canvas.width >= containerWidth) {\n                canvas.minLeft = min(0, newCanvasLeft);\n                canvas.maxLeft = max(0, newCanvasLeft);\n              }\n\n              if (canvas.height >= containerHeight) {\n                canvas.minTop = min(0, newCanvasTop);\n                canvas.maxTop = max(0, newCanvasTop);\n              }\n            }\n          }\n        } else {\n          canvas.minLeft = -canvas.width;\n          canvas.minTop = -canvas.height;\n          canvas.maxLeft = containerWidth;\n          canvas.maxTop = containerHeight;\n        }\n      }\n    },\n\n    renderCanvas: function (isChanged) {\n      var canvas = this.canvas;\n      var image = this.image;\n      var rotate = image.rotate;\n      var naturalWidth = image.naturalWidth;\n      var naturalHeight = image.naturalHeight;\n      var aspectRatio;\n      var rotated;\n\n      if (this.isRotated) {\n        this.isRotated = false;\n\n        // Computes rotated sizes with image sizes\n        rotated = getRotatedSizes({\n          width: image.width,\n          height: image.height,\n          degree: rotate\n        });\n\n        aspectRatio = rotated.width / rotated.height;\n\n        if (aspectRatio !== canvas.aspectRatio) {\n          canvas.left -= (rotated.width - canvas.width) / 2;\n          canvas.top -= (rotated.height - canvas.height) / 2;\n          canvas.width = rotated.width;\n          canvas.height = rotated.height;\n          canvas.aspectRatio = aspectRatio;\n          canvas.naturalWidth = naturalWidth;\n          canvas.naturalHeight = naturalHeight;\n\n          // Computes rotated sizes with natural image sizes\n          if (rotate % 180) {\n            rotated = getRotatedSizes({\n              width: naturalWidth,\n              height: naturalHeight,\n              degree: rotate\n            });\n\n            canvas.naturalWidth = rotated.width;\n            canvas.naturalHeight = rotated.height;\n          }\n\n          this.limitCanvas(true, false);\n        }\n      }\n\n      if (canvas.width > canvas.maxWidth || canvas.width < canvas.minWidth) {\n        canvas.left = canvas.oldLeft;\n      }\n\n      if (canvas.height > canvas.maxHeight || canvas.height < canvas.minHeight) {\n        canvas.top = canvas.oldTop;\n      }\n\n      canvas.width = min(max(canvas.width, canvas.minWidth), canvas.maxWidth);\n      canvas.height = min(max(canvas.height, canvas.minHeight), canvas.maxHeight);\n\n      this.limitCanvas(false, true);\n\n      canvas.oldLeft = canvas.left = min(max(canvas.left, canvas.minLeft), canvas.maxLeft);\n      canvas.oldTop = canvas.top = min(max(canvas.top, canvas.minTop), canvas.maxTop);\n\n      this.$canvas.css({\n        width: canvas.width,\n        height: canvas.height,\n        left: canvas.left,\n        top: canvas.top\n      });\n\n      this.renderImage();\n\n      if (this.isCropped && this.isLimited) {\n        this.limitCropBox(true, true);\n      }\n\n      if (isChanged) {\n        this.output();\n      }\n    },\n\n    renderImage: function (isChanged) {\n      var canvas = this.canvas;\n      var image = this.image;\n      var reversed;\n\n      if (image.rotate) {\n        reversed = getRotatedSizes({\n          width: canvas.width,\n          height: canvas.height,\n          degree: image.rotate,\n          aspectRatio: image.aspectRatio\n        }, true);\n      }\n\n      $.extend(image, reversed ? {\n        width: reversed.width,\n        height: reversed.height,\n        left: (canvas.width - reversed.width) / 2,\n        top: (canvas.height - reversed.height) / 2\n      } : {\n        width: canvas.width,\n        height: canvas.height,\n        left: 0,\n        top: 0\n      });\n\n      this.$clone.css({\n        width: image.width,\n        height: image.height,\n        marginLeft: image.left,\n        marginTop: image.top,\n        transform: getTransform(image)\n      });\n\n      if (isChanged) {\n        this.output();\n      }\n    },\n\n    initCropBox: function () {\n      var options = this.options;\n      var canvas = this.canvas;\n      var aspectRatio = options.aspectRatio;\n      var autoCropArea = num(options.autoCropArea) || 0.8;\n      var cropBox = {\n            width: canvas.width,\n            height: canvas.height\n          };\n\n      if (aspectRatio) {\n        if (canvas.height * aspectRatio > canvas.width) {\n          cropBox.height = cropBox.width / aspectRatio;\n        } else {\n          cropBox.width = cropBox.height * aspectRatio;\n        }\n      }\n\n      this.cropBox = cropBox;\n      this.limitCropBox(true, true);\n\n      // Initialize auto crop area\n      cropBox.width = min(max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);\n      cropBox.height = min(max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);\n\n      // The width of auto crop area must large than \"minWidth\", and the height too. (#164)\n      cropBox.width = max(cropBox.minWidth, cropBox.width * autoCropArea);\n      cropBox.height = max(cropBox.minHeight, cropBox.height * autoCropArea);\n      cropBox.oldLeft = cropBox.left = canvas.left + (canvas.width - cropBox.width) / 2;\n      cropBox.oldTop = cropBox.top = canvas.top + (canvas.height - cropBox.height) / 2;\n\n      this.initialCropBox = $.extend({}, cropBox);\n    },\n\n    limitCropBox: function (isSizeLimited, isPositionLimited) {\n      var options = this.options;\n      var aspectRatio = options.aspectRatio;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var isLimited = this.isLimited;\n      var minCropBoxWidth;\n      var minCropBoxHeight;\n      var maxCropBoxWidth;\n      var maxCropBoxHeight;\n\n      if (isSizeLimited) {\n        minCropBoxWidth = num(options.minCropBoxWidth) || 0;\n        minCropBoxHeight = num(options.minCropBoxHeight) || 0;\n\n        // The min/maxCropBoxWidth/Height must be less than containerWidth/Height\n        minCropBoxWidth = min(minCropBoxWidth, containerWidth);\n        minCropBoxHeight = min(minCropBoxHeight, containerHeight);\n        maxCropBoxWidth = min(containerWidth, isLimited ? canvas.width : containerWidth);\n        maxCropBoxHeight = min(containerHeight, isLimited ? canvas.height : containerHeight);\n\n        if (aspectRatio) {\n          if (minCropBoxWidth && minCropBoxHeight) {\n            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {\n              minCropBoxHeight = minCropBoxWidth / aspectRatio;\n            } else {\n              minCropBoxWidth = minCropBoxHeight * aspectRatio;\n            }\n          } else if (minCropBoxWidth) {\n            minCropBoxHeight = minCropBoxWidth / aspectRatio;\n          } else if (minCropBoxHeight) {\n            minCropBoxWidth = minCropBoxHeight * aspectRatio;\n          }\n\n          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {\n            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;\n          } else {\n            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;\n          }\n        }\n\n        // The minWidth/Height must be less than maxWidth/Height\n        cropBox.minWidth = min(minCropBoxWidth, maxCropBoxWidth);\n        cropBox.minHeight = min(minCropBoxHeight, maxCropBoxHeight);\n        cropBox.maxWidth = maxCropBoxWidth;\n        cropBox.maxHeight = maxCropBoxHeight;\n      }\n\n      if (isPositionLimited) {\n        if (isLimited) {\n          cropBox.minLeft = max(0, canvas.left);\n          cropBox.minTop = max(0, canvas.top);\n          cropBox.maxLeft = min(containerWidth, canvas.left + canvas.width) - cropBox.width;\n          cropBox.maxTop = min(containerHeight, canvas.top + canvas.height) - cropBox.height;\n        } else {\n          cropBox.minLeft = 0;\n          cropBox.minTop = 0;\n          cropBox.maxLeft = containerWidth - cropBox.width;\n          cropBox.maxTop = containerHeight - cropBox.height;\n        }\n      }\n    },\n\n    renderCropBox: function () {\n      var options = this.options;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var cropBox = this.cropBox;\n\n      if (cropBox.width > cropBox.maxWidth || cropBox.width < cropBox.minWidth) {\n        cropBox.left = cropBox.oldLeft;\n      }\n\n      if (cropBox.height > cropBox.maxHeight || cropBox.height < cropBox.minHeight) {\n        cropBox.top = cropBox.oldTop;\n      }\n\n      cropBox.width = min(max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);\n      cropBox.height = min(max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);\n\n      this.limitCropBox(false, true);\n\n      cropBox.oldLeft = cropBox.left = min(max(cropBox.left, cropBox.minLeft), cropBox.maxLeft);\n      cropBox.oldTop = cropBox.top = min(max(cropBox.top, cropBox.minTop), cropBox.maxTop);\n\n      if (options.movable && options.cropBoxMovable) {\n\n        // Turn to move the canvas when the crop box is equal to the container\n        this.$face.data(DATA_ACTION, (cropBox.width === containerWidth && cropBox.height === containerHeight) ? ACTION_MOVE : ACTION_ALL);\n      }\n\n      this.$cropBox.css({\n        width: cropBox.width,\n        height: cropBox.height,\n        left: cropBox.left,\n        top: cropBox.top\n      });\n\n      if (this.isCropped && this.isLimited) {\n        this.limitCanvas(true, true);\n      }\n\n      if (!this.isDisabled) {\n        this.output();\n      }\n    },\n\n    output: function () {\n      this.preview();\n\n      if (this.isCompleted) {\n        this.trigger(EVENT_CROP, this.getData());\n      } else if (!this.isBuilt) {\n\n        // Only trigger one crop event before complete\n        this.$element.one(EVENT_BUILT, $.proxy(function () {\n          this.trigger(EVENT_CROP, this.getData());\n        }, this));\n      }\n    },\n\n    initPreview: function () {\n      var crossOrigin = getCrossOrigin(this.crossOrigin);\n      var url = crossOrigin ? this.crossOriginUrl : this.url;\n      var $clone2;\n\n      this.$preview = $(this.options.preview);\n      this.$clone2 = $clone2 = $('<img' + crossOrigin + ' src=\"' + url + '\">');\n      this.$viewBox.html($clone2);\n      this.$preview.each(function () {\n        var $this = $(this);\n\n        // Save the original size for recover\n        $this.data(DATA_PREVIEW, {\n          width: $this.width(),\n          height: $this.height(),\n          html: $this.html()\n        });\n\n        /**\n         * Override img element styles\n         * Add `display:block` to avoid margin top issue\n         * (Occur only when margin-top <= -height)\n         */\n        $this.html(\n          '<img' + crossOrigin + ' src=\"' + url + '\" style=\"' +\n          'display:block;width:100%;height:auto;' +\n          'min-width:0!important;min-height:0!important;' +\n          'max-width:none!important;max-height:none!important;' +\n          'image-orientation:0deg!important;\">'\n        );\n      });\n    },\n\n    resetPreview: function () {\n      this.$preview.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_PREVIEW);\n\n        $this.css({\n          width: data.width,\n          height: data.height\n        }).html(data.html).removeData(DATA_PREVIEW);\n      });\n    },\n\n    preview: function () {\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var cropBoxWidth = cropBox.width;\n      var cropBoxHeight = cropBox.height;\n      var width = image.width;\n      var height = image.height;\n      var left = cropBox.left - canvas.left - image.left;\n      var top = cropBox.top - canvas.top - image.top;\n\n      if (!this.isCropped || this.isDisabled) {\n        return;\n      }\n\n      this.$clone2.css({\n        width: width,\n        height: height,\n        marginLeft: -left,\n        marginTop: -top,\n        transform: getTransform(image)\n      });\n\n      this.$preview.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_PREVIEW);\n        var originalWidth = data.width;\n        var originalHeight = data.height;\n        var newWidth = originalWidth;\n        var newHeight = originalHeight;\n        var ratio = 1;\n\n        if (cropBoxWidth) {\n          ratio = originalWidth / cropBoxWidth;\n          newHeight = cropBoxHeight * ratio;\n        }\n\n        if (cropBoxHeight && newHeight > originalHeight) {\n          ratio = originalHeight / cropBoxHeight;\n          newWidth = cropBoxWidth * ratio;\n          newHeight = originalHeight;\n        }\n\n        $this.css({\n          width: newWidth,\n          height: newHeight\n        }).find('img').css({\n          width: width * ratio,\n          height: height * ratio,\n          marginLeft: -left * ratio,\n          marginTop: -top * ratio,\n          transform: getTransform(image)\n        });\n      });\n    },\n\n    bind: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $cropper = this.$cropper;\n\n      if ($.isFunction(options.cropstart)) {\n        $this.on(EVENT_CROP_START, options.cropstart);\n      }\n\n      if ($.isFunction(options.cropmove)) {\n        $this.on(EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if ($.isFunction(options.cropend)) {\n        $this.on(EVENT_CROP_END, options.cropend);\n      }\n\n      if ($.isFunction(options.crop)) {\n        $this.on(EVENT_CROP, options.crop);\n      }\n\n      if ($.isFunction(options.zoom)) {\n        $this.on(EVENT_ZOOM, options.zoom);\n      }\n\n      $cropper.on(EVENT_MOUSE_DOWN, $.proxy(this.cropStart, this));\n\n      if (options.zoomable && options.zoomOnWheel) {\n        $cropper.on(EVENT_WHEEL, $.proxy(this.wheel, this));\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        $cropper.on(EVENT_DBLCLICK, $.proxy(this.dblclick, this));\n      }\n\n      $document.\n        on(EVENT_MOUSE_MOVE, (this._cropMove = proxy(this.cropMove, this))).\n        on(EVENT_MOUSE_UP, (this._cropEnd = proxy(this.cropEnd, this)));\n\n      if (options.responsive) {\n        $window.on(EVENT_RESIZE, (this._resize = proxy(this.resize, this)));\n      }\n    },\n\n    unbind: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $cropper = this.$cropper;\n\n      if ($.isFunction(options.cropstart)) {\n        $this.off(EVENT_CROP_START, options.cropstart);\n      }\n\n      if ($.isFunction(options.cropmove)) {\n        $this.off(EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if ($.isFunction(options.cropend)) {\n        $this.off(EVENT_CROP_END, options.cropend);\n      }\n\n      if ($.isFunction(options.crop)) {\n        $this.off(EVENT_CROP, options.crop);\n      }\n\n      if ($.isFunction(options.zoom)) {\n        $this.off(EVENT_ZOOM, options.zoom);\n      }\n\n      $cropper.off(EVENT_MOUSE_DOWN, this.cropStart);\n\n      if (options.zoomable && options.zoomOnWheel) {\n        $cropper.off(EVENT_WHEEL, this.wheel);\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        $cropper.off(EVENT_DBLCLICK, this.dblclick);\n      }\n\n      $document.\n        off(EVENT_MOUSE_MOVE, this._cropMove).\n        off(EVENT_MOUSE_UP, this._cropEnd);\n\n      if (options.responsive) {\n        $window.off(EVENT_RESIZE, this._resize);\n      }\n    },\n\n    resize: function () {\n      var restore = this.options.restore;\n      var $container = this.$container;\n      var container = this.container;\n      var canvasData;\n      var cropBoxData;\n      var ratio;\n\n      // Check `container` is necessary for IE8\n      if (this.isDisabled || !container) {\n        return;\n      }\n\n      ratio = $container.width() / container.width;\n\n      // Resize when width changed or height changed\n      if (ratio !== 1 || $container.height() !== container.height) {\n        if (restore) {\n          canvasData = this.getCanvasData();\n          cropBoxData = this.getCropBoxData();\n        }\n\n        this.render();\n\n        if (restore) {\n          this.setCanvasData($.each(canvasData, function (i, n) {\n            canvasData[i] = n * ratio;\n          }));\n          this.setCropBoxData($.each(cropBoxData, function (i, n) {\n            cropBoxData[i] = n * ratio;\n          }));\n        }\n      }\n    },\n\n    dblclick: function () {\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (this.$dragBox.hasClass(CLASS_CROP)) {\n        this.setDragMode(ACTION_MOVE);\n      } else {\n        this.setDragMode(ACTION_CROP);\n      }\n    },\n\n    wheel: function (event) {\n      var e = event.originalEvent || event;\n      var ratio = num(this.options.wheelZoomRatio) || 0.1;\n      var delta = 1;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      event.preventDefault();\n\n      // Limit wheel speed to prevent zoom too fast\n      if (this.wheeling) {\n        return;\n      }\n\n      this.wheeling = true;\n\n      setTimeout($.proxy(function () {\n        this.wheeling = false;\n      }, this), 50);\n\n      if (e.deltaY) {\n        delta = e.deltaY > 0 ? 1 : -1;\n      } else if (e.wheelDelta) {\n        delta = -e.wheelDelta / 120;\n      } else if (e.detail) {\n        delta = e.detail > 0 ? 1 : -1;\n      }\n\n      this.zoom(-delta * ratio, event);\n    },\n\n    cropStart: function (event) {\n      var options = this.options;\n      var originalEvent = event.originalEvent;\n      var touches = originalEvent && originalEvent.touches;\n      var e = event;\n      var touchesLength;\n      var action;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (touches) {\n        touchesLength = touches.length;\n\n        if (touchesLength > 1) {\n          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {\n            e = touches[1];\n            this.startX2 = e.pageX;\n            this.startY2 = e.pageY;\n            action = ACTION_ZOOM;\n          } else {\n            return;\n          }\n        }\n\n        e = touches[0];\n      }\n\n      action = action || $(e.target).data(DATA_ACTION);\n\n      if (REGEXP_ACTIONS.test(action)) {\n        if (this.trigger(EVENT_CROP_START, {\n          originalEvent: originalEvent,\n          action: action\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        event.preventDefault();\n\n        this.action = action;\n        this.cropping = false;\n\n        // IE8  has `event.pageX/Y`, but not `event.originalEvent.pageX/Y`\n        // IE10 has `event.originalEvent.pageX/Y`, but not `event.pageX/Y`\n        this.startX = e.pageX || originalEvent && originalEvent.pageX;\n        this.startY = e.pageY || originalEvent && originalEvent.pageY;\n\n        if (action === ACTION_CROP) {\n          this.cropping = true;\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n      }\n    },\n\n    cropMove: function (event) {\n      var options = this.options;\n      var originalEvent = event.originalEvent;\n      var touches = originalEvent && originalEvent.touches;\n      var e = event;\n      var action = this.action;\n      var touchesLength;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (touches) {\n        touchesLength = touches.length;\n\n        if (touchesLength > 1) {\n          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {\n            e = touches[1];\n            this.endX2 = e.pageX;\n            this.endY2 = e.pageY;\n          } else {\n            return;\n          }\n        }\n\n        e = touches[0];\n      }\n\n      if (action) {\n        if (this.trigger(EVENT_CROP_MOVE, {\n          originalEvent: originalEvent,\n          action: action\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        event.preventDefault();\n\n        this.endX = e.pageX || originalEvent && originalEvent.pageX;\n        this.endY = e.pageY || originalEvent && originalEvent.pageY;\n\n        this.change(e.shiftKey, action === ACTION_ZOOM ? event : null);\n      }\n    },\n\n    cropEnd: function (event) {\n      var originalEvent = event.originalEvent;\n      var action = this.action;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (action) {\n        event.preventDefault();\n\n        if (this.cropping) {\n          this.cropping = false;\n          this.$dragBox.toggleClass(CLASS_MODAL, this.isCropped && this.options.modal);\n        }\n\n        this.action = '';\n\n        this.trigger(EVENT_CROP_END, {\n          originalEvent: originalEvent,\n          action: action\n        });\n      }\n    },\n\n    change: function (shiftKey, event) {\n      var options = this.options;\n      var aspectRatio = options.aspectRatio;\n      var action = this.action;\n      var container = this.container;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var width = cropBox.width;\n      var height = cropBox.height;\n      var left = cropBox.left;\n      var top = cropBox.top;\n      var right = left + width;\n      var bottom = top + height;\n      var minLeft = 0;\n      var minTop = 0;\n      var maxWidth = container.width;\n      var maxHeight = container.height;\n      var renderable = true;\n      var offset;\n      var range;\n\n      // Locking aspect ratio in \"free mode\" by holding shift key (#259)\n      if (!aspectRatio && shiftKey) {\n        aspectRatio = width && height ? width / height : 1;\n      }\n\n      if (this.limited) {\n        minLeft = cropBox.minLeft;\n        minTop = cropBox.minTop;\n        maxWidth = minLeft + min(container.width, canvas.left + canvas.width);\n        maxHeight = minTop + min(container.height, canvas.top + canvas.height);\n      }\n\n      range = {\n        x: this.endX - this.startX,\n        y: this.endY - this.startY\n      };\n\n      if (aspectRatio) {\n        range.X = range.y * aspectRatio;\n        range.Y = range.x / aspectRatio;\n      }\n\n      switch (action) {\n        // Move crop box\n        case ACTION_ALL:\n          left += range.x;\n          top += range.y;\n          break;\n\n        // Resize crop box\n        case ACTION_EAST:\n          if (range.x >= 0 && (right >= maxWidth || aspectRatio &&\n            (top <= minTop || bottom >= maxHeight))) {\n\n            renderable = false;\n            break;\n          }\n\n          width += range.x;\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top -= range.Y / 2;\n          }\n\n          if (width < 0) {\n            action = ACTION_WEST;\n            width = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH:\n          if (range.y <= 0 && (top <= minTop || aspectRatio &&\n            (left <= minLeft || right >= maxWidth))) {\n\n            renderable = false;\n            break;\n          }\n\n          height -= range.y;\n          top += range.y;\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left += range.X / 2;\n          }\n\n          if (height < 0) {\n            action = ACTION_SOUTH;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_WEST:\n          if (range.x <= 0 && (left <= minLeft || aspectRatio &&\n            (top <= minTop || bottom >= maxHeight))) {\n\n            renderable = false;\n            break;\n          }\n\n          width -= range.x;\n          left += range.x;\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top += range.Y / 2;\n          }\n\n          if (width < 0) {\n            action = ACTION_EAST;\n            width = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH:\n          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio &&\n            (left <= minLeft || right >= maxWidth))) {\n\n            renderable = false;\n            break;\n          }\n\n          height += range.y;\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left -= range.X / 2;\n          }\n\n          if (height < 0) {\n            action = ACTION_NORTH;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH_EAST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {\n              renderable = false;\n              break;\n            }\n\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n          } else {\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_NORTH_WEST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH_WEST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {\n              renderable = false;\n              break;\n            }\n\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n            left += range.X;\n          } else {\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_NORTH_EAST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH_WEST:\n          if (aspectRatio) {\n            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            width -= range.x;\n            left += range.x;\n            height = width / aspectRatio;\n          } else {\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_EAST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH_EAST:\n          if (aspectRatio) {\n            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            width += range.x;\n            height = width / aspectRatio;\n          } else {\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_WEST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = 0;\n          }\n\n          break;\n\n        // Move canvas\n        case ACTION_MOVE:\n          this.move(range.x, range.y);\n          renderable = false;\n          break;\n\n        // Zoom canvas\n        case ACTION_ZOOM:\n          this.zoom((function (x1, y1, x2, y2) {\n            var z1 = sqrt(x1 * x1 + y1 * y1);\n            var z2 = sqrt(x2 * x2 + y2 * y2);\n\n            return (z2 - z1) / z1;\n          })(\n            abs(this.startX - this.startX2),\n            abs(this.startY - this.startY2),\n            abs(this.endX - this.endX2),\n            abs(this.endY - this.endY2)\n          ), event);\n          this.startX2 = this.endX2;\n          this.startY2 = this.endY2;\n          renderable = false;\n          break;\n\n        // Create crop box\n        case ACTION_CROP:\n          if (!range.x || !range.y) {\n            renderable = false;\n            break;\n          }\n\n          offset = this.$cropper.offset();\n          left = this.startX - offset.left;\n          top = this.startY - offset.top;\n          width = cropBox.minWidth;\n          height = cropBox.minHeight;\n\n          if (range.x > 0) {\n            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;\n          } else if (range.x < 0) {\n            left -= width;\n            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;\n          }\n\n          if (range.y < 0) {\n            top -= height;\n          }\n\n          // Show the crop box if is hidden\n          if (!this.isCropped) {\n            this.$cropBox.removeClass(CLASS_HIDDEN);\n            this.isCropped = true;\n\n            if (this.limited) {\n              this.limitCropBox(true, true);\n            }\n          }\n\n          break;\n\n        // No default\n      }\n\n      if (renderable) {\n        cropBox.width = width;\n        cropBox.height = height;\n        cropBox.left = left;\n        cropBox.top = top;\n        this.action = action;\n\n        this.renderCropBox();\n      }\n\n      // Override\n      this.startX = this.endX;\n      this.startY = this.endY;\n    },\n\n    // Show the crop box manually\n    crop: function () {\n      if (!this.isBuilt || this.isDisabled) {\n        return;\n      }\n\n      if (!this.isCropped) {\n        this.isCropped = true;\n        this.limitCropBox(true, true);\n\n        if (this.options.modal) {\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n\n        this.$cropBox.removeClass(CLASS_HIDDEN);\n      }\n\n      this.setCropBoxData(this.initialCropBox);\n    },\n\n    // Reset the image and crop box to their initial states\n    reset: function () {\n      if (!this.isBuilt || this.isDisabled) {\n        return;\n      }\n\n      this.image = $.extend({}, this.initialImage);\n      this.canvas = $.extend({}, this.initialCanvas);\n      this.cropBox = $.extend({}, this.initialCropBox);\n\n      this.renderCanvas();\n\n      if (this.isCropped) {\n        this.renderCropBox();\n      }\n    },\n\n    // Clear the crop box\n    clear: function () {\n      if (!this.isCropped || this.isDisabled) {\n        return;\n      }\n\n      $.extend(this.cropBox, {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      });\n\n      this.isCropped = false;\n      this.renderCropBox();\n\n      this.limitCanvas(true, true);\n\n      // Render canvas after crop box rendered\n      this.renderCanvas();\n\n      this.$dragBox.removeClass(CLASS_MODAL);\n      this.$cropBox.addClass(CLASS_HIDDEN);\n    },\n\n    /**\n     * Replace the image's src and rebuild the cropper\n     *\n     * @param {String} url\n     * @param {Boolean} onlyColorChanged (optional)\n     */\n    replace: function (url, onlyColorChanged) {\n      if (!this.isDisabled && url) {\n        if (this.isImg) {\n          this.$element.attr('src', url);\n        }\n\n        if (onlyColorChanged) {\n          this.url = url;\n          this.$clone.attr('src', url);\n\n          if (this.isBuilt) {\n            this.$preview.find('img').add(this.$clone2).attr('src', url);\n          }\n        } else {\n          if (this.isImg) {\n            this.isReplaced = true;\n          }\n\n          // Clear previous data\n          this.options.data = null;\n          this.load(url);\n        }\n      }\n    },\n\n    // Enable (unfreeze) the cropper\n    enable: function () {\n      if (this.isBuilt) {\n        this.isDisabled = false;\n        this.$cropper.removeClass(CLASS_DISABLED);\n      }\n    },\n\n    // Disable (freeze) the cropper\n    disable: function () {\n      if (this.isBuilt) {\n        this.isDisabled = true;\n        this.$cropper.addClass(CLASS_DISABLED);\n      }\n    },\n\n    // Destroy the cropper and remove the instance from the image\n    destroy: function () {\n      var $this = this.$element;\n\n      if (this.isLoaded) {\n        if (this.isImg && this.isReplaced) {\n          $this.attr('src', this.originalUrl);\n        }\n\n        this.unbuild();\n        $this.removeClass(CLASS_HIDDEN);\n      } else {\n        if (this.isImg) {\n          $this.off(EVENT_LOAD, this.start);\n        } else if (this.$clone) {\n          this.$clone.remove();\n        }\n      }\n\n      $this.removeData(NAMESPACE);\n    },\n\n    /**\n     * Move the canvas with relative offsets\n     *\n     * @param {Number} offsetX\n     * @param {Number} offsetY (optional)\n     */\n    move: function (offsetX, offsetY) {\n      var canvas = this.canvas;\n\n      this.moveTo(\n        isUndefined(offsetX) ? offsetX : canvas.left + num(offsetX),\n        isUndefined(offsetY) ? offsetY : canvas.top + num(offsetY)\n      );\n    },\n\n    /**\n     * Move the canvas to an absolute point\n     *\n     * @param {Number} x\n     * @param {Number} y (optional)\n     */\n    moveTo: function (x, y) {\n      var canvas = this.canvas;\n      var isChanged = false;\n\n      // If \"y\" is not present, its default value is \"x\"\n      if (isUndefined(y)) {\n        y = x;\n      }\n\n      x = num(x);\n      y = num(y);\n\n      if (this.isBuilt && !this.isDisabled && this.options.movable) {\n        if (isNumber(x)) {\n          canvas.left = x;\n          isChanged = true;\n        }\n\n        if (isNumber(y)) {\n          canvas.top = y;\n          isChanged = true;\n        }\n\n        if (isChanged) {\n          this.renderCanvas(true);\n        }\n      }\n    },\n\n    /**\n     * Zoom the canvas with a relative ratio\n     *\n     * @param {Number} ratio\n     * @param {jQuery Event} _event (private)\n     */\n    zoom: function (ratio, _event) {\n      var canvas = this.canvas;\n\n      ratio = num(ratio);\n\n      if (ratio < 0) {\n        ratio =  1 / (1 - ratio);\n      } else {\n        ratio = 1 + ratio;\n      }\n\n      this.zoomTo(canvas.width * ratio / canvas.naturalWidth, _event);\n    },\n\n    /**\n     * Zoom the canvas to an absolute ratio\n     *\n     * @param {Number} ratio\n     * @param {jQuery Event} _event (private)\n     */\n    zoomTo: function (ratio, _event) {\n      var options = this.options;\n      var canvas = this.canvas;\n      var width = canvas.width;\n      var height = canvas.height;\n      var naturalWidth = canvas.naturalWidth;\n      var naturalHeight = canvas.naturalHeight;\n      var originalEvent;\n      var newWidth;\n      var newHeight;\n      var offset;\n      var center;\n\n      ratio = num(ratio);\n\n      if (ratio >= 0 && this.isBuilt && !this.isDisabled && options.zoomable) {\n        newWidth = naturalWidth * ratio;\n        newHeight = naturalHeight * ratio;\n\n        if (_event) {\n          originalEvent = _event.originalEvent;\n        }\n\n        if (this.trigger(EVENT_ZOOM, {\n          originalEvent: originalEvent,\n          oldRatio: width / naturalWidth,\n          ratio: newWidth / naturalWidth\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        if (originalEvent) {\n          offset = this.$cropper.offset();\n          center = originalEvent.touches ? getTouchesCenter(originalEvent.touches) : {\n            pageX: _event.pageX || originalEvent.pageX || 0,\n            pageY: _event.pageY || originalEvent.pageY || 0\n          };\n\n          // Zoom from the triggering point of the event\n          canvas.left -= (newWidth - width) * (\n            ((center.pageX - offset.left) - canvas.left) / width\n          );\n          canvas.top -= (newHeight - height) * (\n            ((center.pageY - offset.top) - canvas.top) / height\n          );\n        } else {\n\n          // Zoom from the center of the canvas\n          canvas.left -= (newWidth - width) / 2;\n          canvas.top -= (newHeight - height) / 2;\n        }\n\n        canvas.width = newWidth;\n        canvas.height = newHeight;\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Rotate the canvas with a relative degree\n     *\n     * @param {Number} degree\n     */\n    rotate: function (degree) {\n      this.rotateTo((this.image.rotate || 0) + num(degree));\n    },\n\n    /**\n     * Rotate the canvas to an absolute degree\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#rotate()\n     *\n     * @param {Number} degree\n     */\n    rotateTo: function (degree) {\n      degree = num(degree);\n\n      if (isNumber(degree) && this.isBuilt && !this.isDisabled && this.options.rotatable) {\n        this.image.rotate = degree % 360;\n        this.isRotated = true;\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Scale the image\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#scale()\n     *\n     * @param {Number} scaleX\n     * @param {Number} scaleY (optional)\n     */\n    scale: function (scaleX, scaleY) {\n      var image = this.image;\n      var isChanged = false;\n\n      // If \"scaleY\" is not present, its default value is \"scaleX\"\n      if (isUndefined(scaleY)) {\n        scaleY = scaleX;\n      }\n\n      scaleX = num(scaleX);\n      scaleY = num(scaleY);\n\n      if (this.isBuilt && !this.isDisabled && this.options.scalable) {\n        if (isNumber(scaleX)) {\n          image.scaleX = scaleX;\n          isChanged = true;\n        }\n\n        if (isNumber(scaleY)) {\n          image.scaleY = scaleY;\n          isChanged = true;\n        }\n\n        if (isChanged) {\n          this.renderImage(true);\n        }\n      }\n    },\n\n    /**\n     * Scale the abscissa of the image\n     *\n     * @param {Number} scaleX\n     */\n    scaleX: function (scaleX) {\n      var scaleY = this.image.scaleY;\n\n      this.scale(scaleX, isNumber(scaleY) ? scaleY : 1);\n    },\n\n    /**\n     * Scale the ordinate of the image\n     *\n     * @param {Number} scaleY\n     */\n    scaleY: function (scaleY) {\n      var scaleX = this.image.scaleX;\n\n      this.scale(isNumber(scaleX) ? scaleX : 1, scaleY);\n    },\n\n    /**\n     * Get the cropped area position and size data (base on the original image)\n     *\n     * @param {Boolean} isRounded (optional)\n     * @return {Object} data\n     */\n    getData: function (isRounded) {\n      var options = this.options;\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var ratio;\n      var data;\n\n      if (this.isBuilt && this.isCropped) {\n        data = {\n          x: cropBox.left - canvas.left,\n          y: cropBox.top - canvas.top,\n          width: cropBox.width,\n          height: cropBox.height\n        };\n\n        ratio = image.width / image.naturalWidth;\n\n        $.each(data, function (i, n) {\n          n = n / ratio;\n          data[i] = isRounded ? round(n) : n;\n        });\n\n      } else {\n        data = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n\n      if (options.rotatable) {\n        data.rotate = image.rotate || 0;\n      }\n\n      if (options.scalable) {\n        data.scaleX = image.scaleX || 1;\n        data.scaleY = image.scaleY || 1;\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the cropped area position and size with new data\n     *\n     * @param {Object} data\n     */\n    setData: function (data) {\n      var options = this.options;\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBoxData = {};\n      var isRotated;\n      var isScaled;\n      var ratio;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.element);\n      }\n\n      if (this.isBuilt && !this.isDisabled && $.isPlainObject(data)) {\n        if (options.rotatable) {\n          if (isNumber(data.rotate) && data.rotate !== image.rotate) {\n            image.rotate = data.rotate;\n            this.isRotated = isRotated = true;\n          }\n        }\n\n        if (options.scalable) {\n          if (isNumber(data.scaleX) && data.scaleX !== image.scaleX) {\n            image.scaleX = data.scaleX;\n            isScaled = true;\n          }\n\n          if (isNumber(data.scaleY) && data.scaleY !== image.scaleY) {\n            image.scaleY = data.scaleY;\n            isScaled = true;\n          }\n        }\n\n        if (isRotated) {\n          this.renderCanvas();\n        } else if (isScaled) {\n          this.renderImage();\n        }\n\n        ratio = image.width / image.naturalWidth;\n\n        if (isNumber(data.x)) {\n          cropBoxData.left = data.x * ratio + canvas.left;\n        }\n\n        if (isNumber(data.y)) {\n          cropBoxData.top = data.y * ratio + canvas.top;\n        }\n\n        if (isNumber(data.width)) {\n          cropBoxData.width = data.width * ratio;\n        }\n\n        if (isNumber(data.height)) {\n          cropBoxData.height = data.height * ratio;\n        }\n\n        this.setCropBoxData(cropBoxData);\n      }\n    },\n\n    /**\n     * Get the container size data\n     *\n     * @return {Object} data\n     */\n    getContainerData: function () {\n      return this.isBuilt ? this.container : {};\n    },\n\n    /**\n     * Get the image position and size data\n     *\n     * @return {Object} data\n     */\n    getImageData: function () {\n      return this.isLoaded ? this.image : {};\n    },\n\n    /**\n     * Get the canvas position and size data\n     *\n     * @return {Object} data\n     */\n    getCanvasData: function () {\n      var canvas = this.canvas;\n      var data = {};\n\n      if (this.isBuilt) {\n        $.each([\n          'left',\n          'top',\n          'width',\n          'height',\n          'naturalWidth',\n          'naturalHeight'\n        ], function (i, n) {\n          data[n] = canvas[n];\n        });\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the canvas position and size with new data\n     *\n     * @param {Object} data\n     */\n    setCanvasData: function (data) {\n      var canvas = this.canvas;\n      var aspectRatio = canvas.aspectRatio;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.$element);\n      }\n\n      if (this.isBuilt && !this.isDisabled && $.isPlainObject(data)) {\n        if (isNumber(data.left)) {\n          canvas.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          canvas.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          canvas.width = data.width;\n          canvas.height = data.width / aspectRatio;\n        } else if (isNumber(data.height)) {\n          canvas.height = data.height;\n          canvas.width = data.height * aspectRatio;\n        }\n\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Get the crop box position and size data\n     *\n     * @return {Object} data\n     */\n    getCropBoxData: function () {\n      var cropBox = this.cropBox;\n      var data;\n\n      if (this.isBuilt && this.isCropped) {\n        data = {\n          left: cropBox.left,\n          top: cropBox.top,\n          width: cropBox.width,\n          height: cropBox.height\n        };\n      }\n\n      return data || {};\n    },\n\n    /**\n     * Set the crop box position and size with new data\n     *\n     * @param {Object} data\n     */\n    setCropBoxData: function (data) {\n      var cropBox = this.cropBox;\n      var aspectRatio = this.options.aspectRatio;\n      var isWidthChanged;\n      var isHeightChanged;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.$element);\n      }\n\n      if (this.isBuilt && this.isCropped && !this.isDisabled && $.isPlainObject(data)) {\n\n        if (isNumber(data.left)) {\n          cropBox.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          cropBox.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          isWidthChanged = true;\n          cropBox.width = data.width;\n        }\n\n        if (isNumber(data.height)) {\n          isHeightChanged = true;\n          cropBox.height = data.height;\n        }\n\n        if (aspectRatio) {\n          if (isWidthChanged) {\n            cropBox.height = cropBox.width / aspectRatio;\n          } else if (isHeightChanged) {\n            cropBox.width = cropBox.height * aspectRatio;\n          }\n        }\n\n        this.renderCropBox();\n      }\n    },\n\n    /**\n     * Get a canvas drawn the cropped image\n     *\n     * @param {Object} options (optional)\n     * @return {HTMLCanvasElement} canvas\n     */\n    getCroppedCanvas: function (options) {\n      var originalWidth;\n      var originalHeight;\n      var canvasWidth;\n      var canvasHeight;\n      var scaledWidth;\n      var scaledHeight;\n      var scaledRatio;\n      var aspectRatio;\n      var canvas;\n      var context;\n      var data;\n\n      if (!this.isBuilt || !this.isCropped || !SUPPORT_CANVAS) {\n        return;\n      }\n\n      if (!$.isPlainObject(options)) {\n        options = {};\n      }\n\n      data = this.getData();\n      originalWidth = data.width;\n      originalHeight = data.height;\n      aspectRatio = originalWidth / originalHeight;\n\n      if ($.isPlainObject(options)) {\n        scaledWidth = options.width;\n        scaledHeight = options.height;\n\n        if (scaledWidth) {\n          scaledHeight = scaledWidth / aspectRatio;\n          scaledRatio = scaledWidth / originalWidth;\n        } else if (scaledHeight) {\n          scaledWidth = scaledHeight * aspectRatio;\n          scaledRatio = scaledHeight / originalHeight;\n        }\n      }\n\n      // The canvas element will use `Math.floor` on a float number, so floor first\n      canvasWidth = floor(scaledWidth || originalWidth);\n      canvasHeight = floor(scaledHeight || originalHeight);\n\n      canvas = $('<canvas>')[0];\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n      context = canvas.getContext('2d');\n\n      if (options.fillColor) {\n        context.fillStyle = options.fillColor;\n        context.fillRect(0, 0, canvasWidth, canvasHeight);\n      }\n\n      // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage\n      context.drawImage.apply(context, (function () {\n        var source = getSourceCanvas(this.$clone[0], this.image);\n        var sourceWidth = source.width;\n        var sourceHeight = source.height;\n        var canvas = this.canvas;\n        var params = [source];\n\n        // Source canvas\n        var srcX = data.x + canvas.naturalWidth * (abs(data.scaleX || 1) - 1) / 2;\n        var srcY = data.y + canvas.naturalHeight * (abs(data.scaleY || 1) - 1) / 2;\n        var srcWidth;\n        var srcHeight;\n\n        // Destination canvas\n        var dstX;\n        var dstY;\n        var dstWidth;\n        var dstHeight;\n\n        if (srcX <= -originalWidth || srcX > sourceWidth) {\n          srcX = srcWidth = dstX = dstWidth = 0;\n        } else if (srcX <= 0) {\n          dstX = -srcX;\n          srcX = 0;\n          srcWidth = dstWidth = min(sourceWidth, originalWidth + srcX);\n        } else if (srcX <= sourceWidth) {\n          dstX = 0;\n          srcWidth = dstWidth = min(originalWidth, sourceWidth - srcX);\n        }\n\n        if (srcWidth <= 0 || srcY <= -originalHeight || srcY > sourceHeight) {\n          srcY = srcHeight = dstY = dstHeight = 0;\n        } else if (srcY <= 0) {\n          dstY = -srcY;\n          srcY = 0;\n          srcHeight = dstHeight = min(sourceHeight, originalHeight + srcY);\n        } else if (srcY <= sourceHeight) {\n          dstY = 0;\n          srcHeight = dstHeight = min(originalHeight, sourceHeight - srcY);\n        }\n\n        // All the numerical parameters should be integer for `drawImage` (#476)\n        params.push(floor(srcX), floor(srcY), floor(srcWidth), floor(srcHeight));\n\n        // Scale destination sizes\n        if (scaledRatio) {\n          dstX *= scaledRatio;\n          dstY *= scaledRatio;\n          dstWidth *= scaledRatio;\n          dstHeight *= scaledRatio;\n        }\n\n        // Avoid \"IndexSizeError\" in IE and Firefox\n        if (dstWidth > 0 && dstHeight > 0) {\n          params.push(floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));\n        }\n\n        return params;\n      }).call(this));\n\n      return canvas;\n    },\n\n    /**\n     * Change the aspect ratio of the crop box\n     *\n     * @param {Number} aspectRatio\n     */\n    setAspectRatio: function (aspectRatio) {\n      var options = this.options;\n\n      if (!this.isDisabled && !isUndefined(aspectRatio)) {\n\n        // 0 -> NaN\n        options.aspectRatio = max(0, aspectRatio) || NaN;\n\n        if (this.isBuilt) {\n          this.initCropBox();\n\n          if (this.isCropped) {\n            this.renderCropBox();\n          }\n        }\n      }\n    },\n\n    /**\n     * Change the drag mode\n     *\n     * @param {String} mode (optional)\n     */\n    setDragMode: function (mode) {\n      var options = this.options;\n      var croppable;\n      var movable;\n\n      if (this.isLoaded && !this.isDisabled) {\n        croppable = mode === ACTION_CROP;\n        movable = options.movable && mode === ACTION_MOVE;\n        mode = (croppable || movable) ? mode : ACTION_NONE;\n\n        this.$dragBox.\n          data(DATA_ACTION, mode).\n          toggleClass(CLASS_CROP, croppable).\n          toggleClass(CLASS_MOVE, movable);\n\n        if (!options.cropBoxMovable) {\n\n          // Sync drag mode to crop box when it is not movable(#300)\n          this.$face.\n            data(DATA_ACTION, mode).\n            toggleClass(CLASS_CROP, croppable).\n            toggleClass(CLASS_MOVE, movable);\n        }\n      }\n    }\n  };\n\n  Cropper.DEFAULTS = {\n\n    // Define the view mode of the cropper\n    viewMode: 0, // 0, 1, 2, 3\n\n    // Define the dragging mode of the cropper\n    dragMode: 'crop', // 'crop', 'move' or 'none'\n\n    // Define the aspect ratio of the crop box\n    aspectRatio: NaN,\n\n    // An object with the previous cropping result data\n    data: null,\n\n    // A jQuery selector for adding extra containers to preview\n    preview: '',\n\n    // Re-render the cropper when resize the window\n    responsive: true,\n\n    // Restore the cropped area after resize the window\n    restore: true,\n\n    // Check if the current image is a cross-origin image\n    checkCrossOrigin: true,\n\n    // Check the current image's Exif Orientation information\n    checkOrientation: true,\n\n    // Show the black modal\n    modal: true,\n\n    // Show the dashed lines for guiding\n    guides: true,\n\n    // Show the center indicator for guiding\n    center: true,\n\n    // Show the white modal to highlight the crop box\n    highlight: true,\n\n    // Show the grid background\n    background: true,\n\n    // Enable to crop the image automatically when initialize\n    autoCrop: true,\n\n    // Define the percentage of automatic cropping area when initializes\n    autoCropArea: 0.8,\n\n    // Enable to move the image\n    movable: true,\n\n    // Enable to rotate the image\n    rotatable: true,\n\n    // Enable to scale the image\n    scalable: true,\n\n    // Enable to zoom the image\n    zoomable: true,\n\n    // Enable to zoom the image by dragging touch\n    zoomOnTouch: true,\n\n    // Enable to zoom the image by wheeling mouse\n    zoomOnWheel: true,\n\n    // Define zoom ratio when zoom the image by wheeling mouse\n    wheelZoomRatio: 0.1,\n\n    // Enable to move the crop box\n    cropBoxMovable: true,\n\n    // Enable to resize the crop box\n    cropBoxResizable: true,\n\n    // Toggle drag mode between \"crop\" and \"move\" when click twice on the cropper\n    toggleDragModeOnDblclick: true,\n\n    // Size limitation\n    minCanvasWidth: 0,\n    minCanvasHeight: 0,\n    minCropBoxWidth: 0,\n    minCropBoxHeight: 0,\n    minContainerWidth: 200,\n    minContainerHeight: 100,\n\n    // Shortcuts of events\n    build: null,\n    built: null,\n    cropstart: null,\n    cropmove: null,\n    cropend: null,\n    crop: null,\n    zoom: null\n  };\n\n  Cropper.setDefaults = function (options) {\n    $.extend(Cropper.DEFAULTS, options);\n  };\n\n  Cropper.TEMPLATE = (\n    '<div class=\"cropper-container\">' +\n      '<div class=\"cropper-wrap-box\">' +\n        '<div class=\"cropper-canvas\"></div>' +\n      '</div>' +\n      '<div class=\"cropper-drag-box\"></div>' +\n      '<div class=\"cropper-crop-box\">' +\n        '<span class=\"cropper-view-box\"></span>' +\n        '<span class=\"cropper-dashed dashed-h\"></span>' +\n        '<span class=\"cropper-dashed dashed-v\"></span>' +\n        '<span class=\"cropper-center\"></span>' +\n        '<span class=\"cropper-face\"></span>' +\n        '<span class=\"cropper-line line-e\" data-action=\"e\"></span>' +\n        '<span class=\"cropper-line line-n\" data-action=\"n\"></span>' +\n        '<span class=\"cropper-line line-w\" data-action=\"w\"></span>' +\n        '<span class=\"cropper-line line-s\" data-action=\"s\"></span>' +\n        '<span class=\"cropper-point point-e\" data-action=\"e\"></span>' +\n        '<span class=\"cropper-point point-n\" data-action=\"n\"></span>' +\n        '<span class=\"cropper-point point-w\" data-action=\"w\"></span>' +\n        '<span class=\"cropper-point point-s\" data-action=\"s\"></span>' +\n        '<span class=\"cropper-point point-ne\" data-action=\"ne\"></span>' +\n        '<span class=\"cropper-point point-nw\" data-action=\"nw\"></span>' +\n        '<span class=\"cropper-point point-sw\" data-action=\"sw\"></span>' +\n        '<span class=\"cropper-point point-se\" data-action=\"se\"></span>' +\n      '</div>' +\n    '</div>'\n  );\n\n  // Save the other cropper\n  Cropper.other = $.fn.cropper;\n\n  // Register as jQuery plugin\n  $.fn.cropper = function (option) {\n    var args = toArray(arguments, 1);\n    var result;\n\n    this.each(function () {\n      var $this = $(this);\n      var data = $this.data(NAMESPACE);\n      var options;\n      var fn;\n\n      if (!data) {\n        if (/destroy/.test(option)) {\n          return;\n        }\n\n        options = $.extend({}, $this.data(), $.isPlainObject(option) && option);\n        $this.data(NAMESPACE, (data = new Cropper(this, options)));\n      }\n\n      if (typeof option === 'string' && $.isFunction(fn = data[option])) {\n        result = fn.apply(data, args);\n      }\n    });\n\n    return isUndefined(result) ? this : result;\n  };\n\n  $.fn.cropper.Constructor = Cropper;\n  $.fn.cropper.setDefaults = Cropper.setDefaults;\n\n  // No conflict\n  $.fn.cropper.noConflict = function () {\n    $.fn.cropper = Cropper.other;\n    return this;\n  };\n\n});\n\n\n/***/ }),\n\n/***/ \"./profile/gl_crop.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vendor_cropper__ = __webpack_require__(\"../../../vendor/assets/javascripts/cropper.js\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vendor_cropper___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_vendor_cropper__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-disable no-useless-escape, max-len, quotes, no-var, no-underscore-dangle, func-names, space-before-function-paren, no-unused-vars, no-return-assign, object-shorthand, one-var, one-var-declaration-per-line, comma-dangle, consistent-return, class-methods-use-this, new-parens */\n\n\n\n(function (global) {\n  // Matches everything but the file name\n  var FILENAMEREGEX = /^.*[\\\\\\/]/;\n\n  var GitLabCrop = function () {\n    function GitLabCrop(input) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          filename = _ref.filename,\n          previewImage = _ref.previewImage,\n          modalCrop = _ref.modalCrop,\n          pickImageEl = _ref.pickImageEl,\n          uploadImageBtn = _ref.uploadImageBtn,\n          modalCropImg = _ref.modalCropImg,\n          _ref$exportWidth = _ref.exportWidth,\n          exportWidth = _ref$exportWidth === undefined ? 200 : _ref$exportWidth,\n          _ref$exportHeight = _ref.exportHeight,\n          exportHeight = _ref$exportHeight === undefined ? 200 : _ref$exportHeight,\n          _ref$cropBoxWidth = _ref.cropBoxWidth,\n          cropBoxWidth = _ref$cropBoxWidth === undefined ? 200 : _ref$cropBoxWidth,\n          _ref$cropBoxHeight = _ref.cropBoxHeight,\n          cropBoxHeight = _ref$cropBoxHeight === undefined ? 200 : _ref$cropBoxHeight;\n\n      _classCallCheck(this, GitLabCrop);\n\n      this.onUploadImageBtnClick = this.onUploadImageBtnClick.bind(this);\n      this.onModalHide = this.onModalHide.bind(this);\n      this.onModalShow = this.onModalShow.bind(this);\n      this.onPickImageClick = this.onPickImageClick.bind(this);\n      this.fileInput = $(input);\n      this.modalCropImg = _.isString(this.modalCropImg) ? $(this.modalCropImg) : this.modalCropImg;\n      this.fileInput.attr('name', this.fileInput.attr('name') + '-trigger').attr('id', this.fileInput.attr('id') + '-trigger');\n      this.exportWidth = exportWidth;\n      this.exportHeight = exportHeight;\n      this.cropBoxWidth = cropBoxWidth;\n      this.cropBoxHeight = cropBoxHeight;\n      this.form = this.fileInput.parents('form');\n      this.filename = filename;\n      this.previewImage = previewImage;\n      this.modalCrop = modalCrop;\n      this.pickImageEl = pickImageEl;\n      this.uploadImageBtn = uploadImageBtn;\n      this.modalCropImg = modalCropImg;\n      this.filename = this.getElement(filename);\n      this.previewImage = this.getElement(previewImage);\n      this.pickImageEl = this.getElement(pickImageEl);\n      this.modalCrop = _.isString(modalCrop) ? $(modalCrop) : modalCrop;\n      this.uploadImageBtn = _.isString(uploadImageBtn) ? $(uploadImageBtn) : uploadImageBtn;\n      this.modalCropImg = _.isString(modalCropImg) ? $(modalCropImg) : modalCropImg;\n      this.cropActionsBtn = this.modalCrop.find('[data-method]');\n      this.bindEvents();\n    }\n\n    _createClass(GitLabCrop, [{\n      key: 'getElement',\n      value: function getElement(selector) {\n        return $(selector, this.form);\n      }\n    }, {\n      key: 'bindEvents',\n      value: function bindEvents() {\n        var _this;\n        _this = this;\n        this.fileInput.on('change', function (e) {\n          return _this.onFileInputChange(e, this);\n        });\n        this.pickImageEl.on('click', this.onPickImageClick);\n        this.modalCrop.on('shown.bs.modal', this.onModalShow);\n        this.modalCrop.on('hidden.bs.modal', this.onModalHide);\n        this.uploadImageBtn.on('click', this.onUploadImageBtnClick);\n        this.cropActionsBtn.on('click', function (e) {\n          var btn;\n          btn = this;\n          return _this.onActionBtnClick(btn);\n        });\n        return this.croppedImageBlob = null;\n      }\n    }, {\n      key: 'onPickImageClick',\n      value: function onPickImageClick() {\n        return this.fileInput.trigger('click');\n      }\n    }, {\n      key: 'onModalShow',\n      value: function onModalShow() {\n        var _this;\n        _this = this;\n        return this.modalCropImg.cropper({\n          viewMode: 1,\n          center: false,\n          aspectRatio: 1,\n          modal: true,\n          scalable: false,\n          rotatable: false,\n          zoomable: true,\n          dragMode: 'move',\n          guides: false,\n          zoomOnTouch: false,\n          zoomOnWheel: false,\n          cropBoxMovable: false,\n          cropBoxResizable: false,\n          toggleDragModeOnDblclick: false,\n          built: function built() {\n            var $image, container, cropBoxHeight, cropBoxWidth;\n            $image = $(this);\n            container = $image.cropper('getContainerData');\n            cropBoxWidth = _this.cropBoxWidth;\n            cropBoxHeight = _this.cropBoxHeight;\n            return $image.cropper('setCropBoxData', {\n              width: cropBoxWidth,\n              height: cropBoxHeight,\n              left: (container.width - cropBoxWidth) / 2,\n              top: (container.height - cropBoxHeight) / 2\n            });\n          }\n        });\n      }\n    }, {\n      key: 'onModalHide',\n      value: function onModalHide() {\n        return this.modalCropImg.attr('src', '').cropper('destroy');\n      }\n    }, {\n      key: 'onUploadImageBtnClick',\n      value: function onUploadImageBtnClick(e) {\n        e.preventDefault();\n        this.setBlob();\n        this.setPreview();\n        this.modalCrop.modal('hide');\n        return this.fileInput.val('');\n      }\n    }, {\n      key: 'onActionBtnClick',\n      value: function onActionBtnClick(btn) {\n        var data, result;\n        data = $(btn).data();\n        if (this.modalCropImg.data('cropper') && data.method) {\n          return result = this.modalCropImg.cropper(data.method, data.option);\n        }\n      }\n    }, {\n      key: 'onFileInputChange',\n      value: function onFileInputChange(e, input) {\n        return this.readFile(input);\n      }\n    }, {\n      key: 'readFile',\n      value: function readFile(input) {\n        var _this, reader;\n        _this = this;\n        reader = new FileReader();\n        reader.onload = function () {\n          _this.modalCropImg.attr('src', reader.result);\n          return _this.modalCrop.modal('show');\n        };\n        return reader.readAsDataURL(input.files[0]);\n      }\n    }, {\n      key: 'dataURLtoBlob',\n      value: function dataURLtoBlob(dataURL) {\n        var array, binary, i, k, len, v;\n        binary = atob(dataURL.split(',')[1]);\n        array = [];\n        for (k = i = 0, len = binary.length; i < len; k = i += 1) {\n          v = binary[k];\n          array.push(binary.charCodeAt(k));\n        }\n        return new Blob([new Uint8Array(array)], {\n          type: 'image/png'\n        });\n      }\n    }, {\n      key: 'setPreview',\n      value: function setPreview() {\n        var filename;\n        this.previewImage.attr('src', this.dataURL);\n        filename = this.fileInput.val().replace(FILENAMEREGEX, '');\n        return this.filename.text(filename);\n      }\n    }, {\n      key: 'setBlob',\n      value: function setBlob() {\n        this.dataURL = this.modalCropImg.cropper('getCroppedCanvas', {\n          width: 200,\n          height: 200\n        }).toDataURL('image/png');\n        return this.croppedImageBlob = this.dataURLtoBlob(this.dataURL);\n      }\n    }, {\n      key: 'getBlob',\n      value: function getBlob() {\n        return this.croppedImageBlob;\n      }\n    }]);\n\n    return GitLabCrop;\n  }();\n\n  $.fn.glCrop = function (opts) {\n    return this.each(function () {\n      return $(this).data('glcrop', new GitLabCrop(this, opts));\n    });\n  };\n})(window.gl || (window.gl = {}));\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(\"../../../node_modules/jquery/dist/jquery.js\")))\n\n/***/ }),\n\n/***/ \"./profile/profile.js\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($) {var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* eslint-disable comma-dangle, no-unused-vars, class-methods-use-this, quotes, consistent-return, func-names, prefer-arrow-callback, space-before-function-paren, max-len */\n/* global Flash */\n\n(function (global) {\n  var Profile = function () {\n    function Profile() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          form = _ref.form;\n\n      _classCallCheck(this, Profile);\n\n      this.onSubmitForm = this.onSubmitForm.bind(this);\n      this.form = form || $('.edit-user');\n      this.bindEvents();\n      this.initAvatarGlCrop();\n    }\n\n    _createClass(Profile, [{\n      key: 'initAvatarGlCrop',\n      value: function initAvatarGlCrop() {\n        var cropOpts = {\n          filename: '.js-avatar-filename',\n          previewImage: '.avatar-image .avatar',\n          modalCrop: '.modal-profile-crop',\n          pickImageEl: '.js-choose-user-avatar-button',\n          uploadImageBtn: '.js-upload-user-avatar',\n          modalCropImg: '.modal-profile-crop-image'\n        };\n        this.avatarGlCrop = $('.js-user-avatar-input').glCrop(cropOpts).data('glcrop');\n      }\n    }, {\n      key: 'bindEvents',\n      value: function bindEvents() {\n        $('.js-preferences-form').on('change.preference', 'input[type=radio]', this.submitForm);\n        $('#user_notification_email').on('change', this.submitForm);\n        $('#user_notified_of_own_activity').on('change', this.submitForm);\n        $('.update-username').on('ajax:before', this.beforeUpdateUsername);\n        $('.update-username').on('ajax:complete', this.afterUpdateUsername);\n        $('.update-notifications').on('ajax:success', this.onUpdateNotifs);\n        this.form.on('submit', this.onSubmitForm);\n      }\n    }, {\n      key: 'submitForm',\n      value: function submitForm() {\n        return $(this).parents('form').submit();\n      }\n    }, {\n      key: 'onSubmitForm',\n      value: function onSubmitForm(e) {\n        e.preventDefault();\n        return this.saveForm();\n      }\n    }, {\n      key: 'beforeUpdateUsername',\n      value: function beforeUpdateUsername() {\n        $('.loading-username', this).removeClass('hidden');\n      }\n    }, {\n      key: 'afterUpdateUsername',\n      value: function afterUpdateUsername() {\n        $('.loading-username', this).addClass('hidden');\n        $('button[type=submit]', this).enable();\n      }\n    }, {\n      key: 'onUpdateNotifs',\n      value: function onUpdateNotifs(e, data) {\n        return data.saved ? new Flash(\"Notification settings saved\", \"notice\") : new Flash(\"Failed to save new settings\", \"alert\");\n      }\n    }, {\n      key: 'saveForm',\n      value: function saveForm() {\n        var self = this;\n        var formData = new FormData(this.form[0]);\n        var avatarBlob = this.avatarGlCrop.getBlob();\n\n        if (avatarBlob != null) {\n          formData.append('user[avatar]', avatarBlob, 'avatar.png');\n        }\n\n        return $.ajax({\n          url: this.form.attr('action'),\n          type: this.form.attr('method'),\n          data: formData,\n          dataType: \"json\",\n          processData: false,\n          contentType: false,\n          success: function success(response) {\n            return new Flash(response.message, 'notice');\n          },\n          error: function error(jqXHR) {\n            return new Flash(jqXHR.responseJSON.message, 'alert');\n          },\n          complete: function complete() {\n            window.scrollTo(0, 0);\n            // Enable submit button after requests ends\n            return self.form.find(':input[disabled]').enable();\n          }\n        });\n      }\n    }]);\n\n    return Profile;\n  }();\n\n  $(function () {\n    $(document).on('input.ssh_key', '#key_key', function () {\n      var $title = $('#key_title');\n      var comment = $(this).val().match(/^\\S+ \\S+ (.+)\\n?$/);\n\n      // Extract the SSH Key title from its comment\n      if (comment && comment.length > 1) {\n        return $title.val(comment[1]).change();\n      }\n    });\n    if (global.utils.getPagePath() === 'profiles') {\n      return new Profile();\n    }\n  });\n})(window.gl || (window.gl = {}));\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"../../../node_modules/jquery/dist/jquery.js\")))\n\n/***/ }),\n\n/***/ \"./profile/profile_bundle.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_crop__ = __webpack_require__(\"./profile/gl_crop.js\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__profile__ = __webpack_require__(\"./profile/profile.js\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__profile___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__profile__);\n\n\n\n/***/ })\n\n},[\"./profile/profile_bundle.js\"]);\n\n\n// WEBPACK FOOTER //\n// profile.52358687f8cae25cd721.bundle.js","/*!\n * Cropper v2.3.0\n * https://github.com/fengyuanchen/cropper\n *\n * Copyright (c) 2014-2016 Fengyuan Chen and contributors\n * Released under the MIT license\n *\n * Date: 2016-02-22T02:13:13.332Z\n */\n\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as anonymous module.\n    define(['jquery'], factory);\n  } else if (typeof exports === 'object') {\n    // Node / CommonJS\n    factory(require('jquery'));\n  } else {\n    // Browser globals.\n    factory(jQuery);\n  }\n})(function ($) {\n\n  'use strict';\n\n  // Globals\n  var $window = $(window);\n  var $document = $(document);\n  var location = window.location;\n  var navigator = window.navigator;\n  var ArrayBuffer = window.ArrayBuffer;\n  var Uint8Array = window.Uint8Array;\n  var DataView = window.DataView;\n  var btoa = window.btoa;\n\n  // Constants\n  var NAMESPACE = 'cropper';\n\n  // Classes\n  var CLASS_MODAL = 'cropper-modal';\n  var CLASS_HIDE = 'cropper-hide';\n  var CLASS_HIDDEN = 'cropper-hidden';\n  var CLASS_INVISIBLE = 'cropper-invisible';\n  var CLASS_MOVE = 'cropper-move';\n  var CLASS_CROP = 'cropper-crop';\n  var CLASS_DISABLED = 'cropper-disabled';\n  var CLASS_BG = 'cropper-bg';\n\n  // Events\n  var EVENT_MOUSE_DOWN = 'mousedown touchstart pointerdown MSPointerDown';\n  var EVENT_MOUSE_MOVE = 'mousemove touchmove pointermove MSPointerMove';\n  var EVENT_MOUSE_UP = 'mouseup touchend touchcancel pointerup pointercancel MSPointerUp MSPointerCancel';\n  var EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';\n  var EVENT_DBLCLICK = 'dblclick';\n  var EVENT_LOAD = 'load.' + NAMESPACE;\n  var EVENT_ERROR = 'error.' + NAMESPACE;\n  var EVENT_RESIZE = 'resize.' + NAMESPACE; // Bind to window with namespace\n  var EVENT_BUILD = 'build.' + NAMESPACE;\n  var EVENT_BUILT = 'built.' + NAMESPACE;\n  var EVENT_CROP_START = 'cropstart.' + NAMESPACE;\n  var EVENT_CROP_MOVE = 'cropmove.' + NAMESPACE;\n  var EVENT_CROP_END = 'cropend.' + NAMESPACE;\n  var EVENT_CROP = 'crop.' + NAMESPACE;\n  var EVENT_ZOOM = 'zoom.' + NAMESPACE;\n\n  // RegExps\n  var REGEXP_ACTIONS = /e|w|s|n|se|sw|ne|nw|all|crop|move|zoom/;\n  var REGEXP_DATA_URL = /^data\\:/;\n  var REGEXP_DATA_URL_HEAD = /^data\\:([^\\;]+)\\;base64,/;\n  var REGEXP_DATA_URL_JPEG = /^data\\:image\\/jpeg.*;base64,/;\n\n  // Data keys\n  var DATA_PREVIEW = 'preview';\n  var DATA_ACTION = 'action';\n\n  // Actions\n  var ACTION_EAST = 'e';\n  var ACTION_WEST = 'w';\n  var ACTION_SOUTH = 's';\n  var ACTION_NORTH = 'n';\n  var ACTION_SOUTH_EAST = 'se';\n  var ACTION_SOUTH_WEST = 'sw';\n  var ACTION_NORTH_EAST = 'ne';\n  var ACTION_NORTH_WEST = 'nw';\n  var ACTION_ALL = 'all';\n  var ACTION_CROP = 'crop';\n  var ACTION_MOVE = 'move';\n  var ACTION_ZOOM = 'zoom';\n  var ACTION_NONE = 'none';\n\n  // Supports\n  var SUPPORT_CANVAS = $.isFunction($('<canvas>')[0].getContext);\n  var IS_SAFARI = navigator && /safari/i.test(navigator.userAgent) && /apple computer/i.test(navigator.vendor);\n\n  // Maths\n  var num = Number;\n  var min = Math.min;\n  var max = Math.max;\n  var abs = Math.abs;\n  var sin = Math.sin;\n  var cos = Math.cos;\n  var sqrt = Math.sqrt;\n  var round = Math.round;\n  var floor = Math.floor;\n\n  // Utilities\n  var fromCharCode = String.fromCharCode;\n\n  function isNumber(n) {\n    return typeof n === 'number' && !isNaN(n);\n  }\n\n  function isUndefined(n) {\n    return typeof n === 'undefined';\n  }\n\n  function toArray(obj, offset) {\n    var args = [];\n\n    // This is necessary for IE8\n    if (isNumber(offset)) {\n      args.push(offset);\n    }\n\n    return args.slice.apply(obj, args);\n  }\n\n  // Custom proxy to avoid jQuery's guid\n  function proxy(fn, context) {\n    var args = toArray(arguments, 2);\n\n    return function () {\n      return fn.apply(context, args.concat(toArray(arguments)));\n    };\n  }\n\n  function isCrossOriginURL(url) {\n    var parts = url.match(/^(https?:)\\/\\/([^\\:\\/\\?#]+):?(\\d*)/i);\n\n    return parts && (\n      parts[1] !== location.protocol ||\n      parts[2] !== location.hostname ||\n      parts[3] !== location.port\n    );\n  }\n\n  function addTimestamp(url) {\n    var timestamp = 'timestamp=' + (new Date()).getTime();\n\n    return (url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp);\n  }\n\n  function getCrossOrigin(crossOrigin) {\n    return crossOrigin ? ' crossOrigin=\"' + crossOrigin + '\"' : '';\n  }\n\n  function getImageSize(image, callback) {\n    var newImage;\n\n    // Modern browsers (ignore Safari, #120 & #509)\n    if (image.naturalWidth && !IS_SAFARI) {\n      return callback(image.naturalWidth, image.naturalHeight);\n    }\n\n    // IE8: Don't use `new Image()` here (#319)\n    newImage = document.createElement('img');\n\n    newImage.onload = function () {\n      callback(this.width, this.height);\n    };\n\n    newImage.src = image.src;\n  }\n\n  function getTransform(options) {\n    var transforms = [];\n    var rotate = options.rotate;\n    var scaleX = options.scaleX;\n    var scaleY = options.scaleY;\n\n    if (isNumber(rotate)) {\n      transforms.push('rotate(' + rotate + 'deg)');\n    }\n\n    if (isNumber(scaleX) && isNumber(scaleY)) {\n      transforms.push('scale(' + scaleX + ',' + scaleY + ')');\n    }\n\n    return transforms.length ? transforms.join(' ') : 'none';\n  }\n\n  function getRotatedSizes(data, isReversed) {\n    var deg = abs(data.degree) % 180;\n    var arc = (deg > 90 ? (180 - deg) : deg) * Math.PI / 180;\n    var sinArc = sin(arc);\n    var cosArc = cos(arc);\n    var width = data.width;\n    var height = data.height;\n    var aspectRatio = data.aspectRatio;\n    var newWidth;\n    var newHeight;\n\n    if (!isReversed) {\n      newWidth = width * cosArc + height * sinArc;\n      newHeight = width * sinArc + height * cosArc;\n    } else {\n      newWidth = width / (cosArc + sinArc / aspectRatio);\n      newHeight = newWidth / aspectRatio;\n    }\n\n    return {\n      width: newWidth,\n      height: newHeight\n    };\n  }\n\n  function getSourceCanvas(image, data) {\n    var canvas = $('<canvas>')[0];\n    var context = canvas.getContext('2d');\n    var dstX = 0;\n    var dstY = 0;\n    var dstWidth = data.naturalWidth;\n    var dstHeight = data.naturalHeight;\n    var rotate = data.rotate;\n    var scaleX = data.scaleX;\n    var scaleY = data.scaleY;\n    var scalable = isNumber(scaleX) && isNumber(scaleY) && (scaleX !== 1 || scaleY !== 1);\n    var rotatable = isNumber(rotate) && rotate !== 0;\n    var advanced = rotatable || scalable;\n    var canvasWidth = dstWidth * abs(scaleX || 1);\n    var canvasHeight = dstHeight * abs(scaleY || 1);\n    var translateX;\n    var translateY;\n    var rotated;\n\n    if (scalable) {\n      translateX = canvasWidth / 2;\n      translateY = canvasHeight / 2;\n    }\n\n    if (rotatable) {\n      rotated = getRotatedSizes({\n        width: canvasWidth,\n        height: canvasHeight,\n        degree: rotate\n      });\n\n      canvasWidth = rotated.width;\n      canvasHeight = rotated.height;\n      translateX = canvasWidth / 2;\n      translateY = canvasHeight / 2;\n    }\n\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n\n    if (advanced) {\n      dstX = -dstWidth / 2;\n      dstY = -dstHeight / 2;\n\n      context.save();\n      context.translate(translateX, translateY);\n    }\n\n    if (rotatable) {\n      context.rotate(rotate * Math.PI / 180);\n    }\n\n    // Should call `scale` after rotated\n    if (scalable) {\n      context.scale(scaleX, scaleY);\n    }\n\n    context.drawImage(image, floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));\n\n    if (advanced) {\n      context.restore();\n    }\n\n    return canvas;\n  }\n\n  function getTouchesCenter(touches) {\n    var length = touches.length;\n    var pageX = 0;\n    var pageY = 0;\n\n    if (length) {\n      $.each(touches, function (i, touch) {\n        pageX += touch.pageX;\n        pageY += touch.pageY;\n      });\n\n      pageX /= length;\n      pageY /= length;\n    }\n\n    return {\n      pageX: pageX,\n      pageY: pageY\n    };\n  }\n\n  function getStringFromCharCode(dataView, start, length) {\n    var str = '';\n    var i;\n\n    for (i = start, length += start; i < length; i++) {\n      str += fromCharCode(dataView.getUint8(i));\n    }\n\n    return str;\n  }\n\n  function getOrientation(arrayBuffer) {\n    var dataView = new DataView(arrayBuffer);\n    var length = dataView.byteLength;\n    var orientation;\n    var exifIDCode;\n    var tiffOffset;\n    var firstIFDOffset;\n    var littleEndian;\n    var endianness;\n    var app1Start;\n    var ifdStart;\n    var offset;\n    var i;\n\n    // Only handle JPEG image (start by 0xFFD8)\n    if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {\n      offset = 2;\n\n      while (offset < length) {\n        if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {\n          app1Start = offset;\n          break;\n        }\n\n        offset++;\n      }\n    }\n\n    if (app1Start) {\n      exifIDCode = app1Start + 4;\n      tiffOffset = app1Start + 10;\n\n      if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {\n        endianness = dataView.getUint16(tiffOffset);\n        littleEndian = endianness === 0x4949;\n\n        if (littleEndian || endianness === 0x4D4D /* bigEndian */) {\n          if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {\n            firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);\n\n            if (firstIFDOffset >= 0x00000008) {\n              ifdStart = tiffOffset + firstIFDOffset;\n            }\n          }\n        }\n      }\n    }\n\n    if (ifdStart) {\n      length = dataView.getUint16(ifdStart, littleEndian);\n\n      for (i = 0; i < length; i++) {\n        offset = ifdStart + i * 12 + 2;\n\n        if (dataView.getUint16(offset, littleEndian) === 0x0112 /* Orientation */) {\n\n          // 8 is the offset of the current tag's value\n          offset += 8;\n\n          // Get the original orientation value\n          orientation = dataView.getUint16(offset, littleEndian);\n\n          // Override the orientation with its default value for Safari (#120)\n          if (IS_SAFARI) {\n            dataView.setUint16(offset, 1, littleEndian);\n          }\n\n          break;\n        }\n      }\n    }\n\n    return orientation;\n  }\n\n  function dataURLToArrayBuffer(dataURL) {\n    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');\n    var binary = atob(base64);\n    var length = binary.length;\n    var arrayBuffer = new ArrayBuffer(length);\n    var dataView = new Uint8Array(arrayBuffer);\n    var i;\n\n    for (i = 0; i < length; i++) {\n      dataView[i] = binary.charCodeAt(i);\n    }\n\n    return arrayBuffer;\n  }\n\n  // Only available for JPEG image\n  function arrayBufferToDataURL(arrayBuffer) {\n    var dataView = new Uint8Array(arrayBuffer);\n    var length = dataView.length;\n    var base64 = '';\n    var i;\n\n    for (i = 0; i < length; i++) {\n      base64 += fromCharCode(dataView[i]);\n    }\n\n    return 'data:image/jpeg;base64,' + btoa(base64);\n  }\n\n  function Cropper(element, options) {\n    this.$element = $(element);\n    this.options = $.extend({}, Cropper.DEFAULTS, $.isPlainObject(options) && options);\n    this.isLoaded = false;\n    this.isBuilt = false;\n    this.isCompleted = false;\n    this.isRotated = false;\n    this.isCropped = false;\n    this.isDisabled = false;\n    this.isReplaced = false;\n    this.isLimited = false;\n    this.wheeling = false;\n    this.isImg = false;\n    this.originalUrl = '';\n    this.canvas = null;\n    this.cropBox = null;\n    this.init();\n  }\n\n  Cropper.prototype = {\n    constructor: Cropper,\n\n    init: function () {\n      var $this = this.$element;\n      var url;\n\n      if ($this.is('img')) {\n        this.isImg = true;\n\n        // Should use `$.fn.attr` here. e.g.: \"img/picture.jpg\"\n        this.originalUrl = url = $this.attr('src');\n\n        // Stop when it's a blank image\n        if (!url) {\n          return;\n        }\n\n        // Should use `$.fn.prop` here. e.g.: \"http://example.com/img/picture.jpg\"\n        url = $this.prop('src');\n      } else if ($this.is('canvas') && SUPPORT_CANVAS) {\n        url = $this[0].toDataURL();\n      }\n\n      this.load(url);\n    },\n\n    // A shortcut for triggering custom events\n    trigger: function (type, data) {\n      var e = $.Event(type, data);\n\n      this.$element.trigger(e);\n\n      return e;\n    },\n\n    load: function (url) {\n      var options = this.options;\n      var $this = this.$element;\n      var read;\n      var xhr;\n\n      if (!url) {\n        return;\n      }\n\n      // Trigger build event first\n      $this.one(EVENT_BUILD, options.build);\n\n      if (this.trigger(EVENT_BUILD).isDefaultPrevented()) {\n        return;\n      }\n\n      this.url = url;\n      this.image = {};\n\n      if (!options.checkOrientation || !ArrayBuffer) {\n        return this.clone();\n      }\n\n      read = $.proxy(this.read, this);\n\n      // XMLHttpRequest disallows to open a Data URL in some browsers like IE11 and Safari\n      if (REGEXP_DATA_URL.test(url)) {\n        return REGEXP_DATA_URL_JPEG.test(url) ?\n          read(dataURLToArrayBuffer(url)) :\n          this.clone();\n      }\n\n      xhr = new XMLHttpRequest();\n\n      xhr.onerror = xhr.onabort = $.proxy(function () {\n        this.clone();\n      }, this);\n\n      xhr.onload = function () {\n        read(this.response);\n      };\n\n      xhr.open('get', url);\n      xhr.responseType = 'arraybuffer';\n      xhr.send();\n    },\n\n    read: function (arrayBuffer) {\n      var options = this.options;\n      var orientation = getOrientation(arrayBuffer);\n      var image = this.image;\n      var rotate;\n      var scaleX;\n      var scaleY;\n\n      if (orientation > 1) {\n        this.url = arrayBufferToDataURL(arrayBuffer);\n\n        switch (orientation) {\n\n          // flip horizontal\n          case 2:\n            scaleX = -1;\n            break;\n\n          // rotate left 180\n          case 3:\n            rotate = -180;\n            break;\n\n          // flip vertical\n          case 4:\n            scaleY = -1;\n            break;\n\n          // flip vertical + rotate right 90\n          case 5:\n            rotate = 90;\n            scaleY = -1;\n            break;\n\n          // rotate right 90\n          case 6:\n            rotate = 90;\n            break;\n\n          // flip horizontal + rotate right 90\n          case 7:\n            rotate = 90;\n            scaleX = -1;\n            break;\n\n          // rotate left 90\n          case 8:\n            rotate = -90;\n            break;\n        }\n      }\n\n      if (options.rotatable) {\n        image.rotate = rotate;\n      }\n\n      if (options.scalable) {\n        image.scaleX = scaleX;\n        image.scaleY = scaleY;\n      }\n\n      this.clone();\n    },\n\n    clone: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var url = this.url;\n      var crossOrigin = '';\n      var crossOriginUrl;\n      var $clone;\n\n      if (options.checkCrossOrigin && isCrossOriginURL(url)) {\n        crossOrigin = $this.prop('crossOrigin');\n\n        if (crossOrigin) {\n          crossOriginUrl = url;\n        } else {\n          crossOrigin = 'anonymous';\n\n          // Bust cache (#148) when there is not a \"crossOrigin\" property\n          crossOriginUrl = addTimestamp(url);\n        }\n      }\n\n      this.crossOrigin = crossOrigin;\n      this.crossOriginUrl = crossOriginUrl;\n      this.$clone = $clone = $('<img' + getCrossOrigin(crossOrigin) + ' src=\"' + (crossOriginUrl || url) + '\">');\n\n      if (this.isImg) {\n        if ($this[0].complete) {\n          this.start();\n        } else {\n          $this.one(EVENT_LOAD, $.proxy(this.start, this));\n        }\n      } else {\n        $clone.\n          one(EVENT_LOAD, $.proxy(this.start, this)).\n          one(EVENT_ERROR, $.proxy(this.stop, this)).\n          addClass(CLASS_HIDE).\n          insertAfter($this);\n      }\n    },\n\n    start: function () {\n      var $image = this.$element;\n      var $clone = this.$clone;\n\n      if (!this.isImg) {\n        $clone.off(EVENT_ERROR, this.stop);\n        $image = $clone;\n      }\n\n      getImageSize($image[0], $.proxy(function (naturalWidth, naturalHeight) {\n        $.extend(this.image, {\n          naturalWidth: naturalWidth,\n          naturalHeight: naturalHeight,\n          aspectRatio: naturalWidth / naturalHeight\n        });\n\n        this.isLoaded = true;\n        this.build();\n      }, this));\n    },\n\n    stop: function () {\n      this.$clone.remove();\n      this.$clone = null;\n    },\n\n    build: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $clone = this.$clone;\n      var $cropper;\n      var $cropBox;\n      var $face;\n\n      if (!this.isLoaded) {\n        return;\n      }\n\n      // Unbuild first when replace\n      if (this.isBuilt) {\n        this.unbuild();\n      }\n\n      // Create cropper elements\n      this.$container = $this.parent();\n      this.$cropper = $cropper = $(Cropper.TEMPLATE);\n      this.$canvas = $cropper.find('.cropper-canvas').append($clone);\n      this.$dragBox = $cropper.find('.cropper-drag-box');\n      this.$cropBox = $cropBox = $cropper.find('.cropper-crop-box');\n      this.$viewBox = $cropper.find('.cropper-view-box');\n      this.$face = $face = $cropBox.find('.cropper-face');\n\n      // Hide the original image\n      $this.addClass(CLASS_HIDDEN).after($cropper);\n\n      // Show the clone image if is hidden\n      if (!this.isImg) {\n        $clone.removeClass(CLASS_HIDE);\n      }\n\n      this.initPreview();\n      this.bind();\n\n      options.aspectRatio = max(0, options.aspectRatio) || NaN;\n      options.viewMode = max(0, min(3, round(options.viewMode))) || 0;\n\n      if (options.autoCrop) {\n        this.isCropped = true;\n\n        if (options.modal) {\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n      } else {\n        $cropBox.addClass(CLASS_HIDDEN);\n      }\n\n      if (!options.guides) {\n        $cropBox.find('.cropper-dashed').addClass(CLASS_HIDDEN);\n      }\n\n      if (!options.center) {\n        $cropBox.find('.cropper-center').addClass(CLASS_HIDDEN);\n      }\n\n      if (options.cropBoxMovable) {\n        $face.addClass(CLASS_MOVE).data(DATA_ACTION, ACTION_ALL);\n      }\n\n      if (!options.highlight) {\n        $face.addClass(CLASS_INVISIBLE);\n      }\n\n      if (options.background) {\n        $cropper.addClass(CLASS_BG);\n      }\n\n      if (!options.cropBoxResizable) {\n        $cropBox.find('.cropper-line, .cropper-point').addClass(CLASS_HIDDEN);\n      }\n\n      this.setDragMode(options.dragMode);\n      this.render();\n      this.isBuilt = true;\n      this.setData(options.data);\n      $this.one(EVENT_BUILT, options.built);\n\n      // Trigger the built event asynchronously to keep `data('cropper')` is defined\n      setTimeout($.proxy(function () {\n        this.trigger(EVENT_BUILT);\n        this.isCompleted = true;\n      }, this), 0);\n    },\n\n    unbuild: function () {\n      if (!this.isBuilt) {\n        return;\n      }\n\n      this.isBuilt = false;\n      this.isCompleted = false;\n      this.initialImage = null;\n\n      // Clear `initialCanvas` is necessary when replace\n      this.initialCanvas = null;\n      this.initialCropBox = null;\n      this.container = null;\n      this.canvas = null;\n\n      // Clear `cropBox` is necessary when replace\n      this.cropBox = null;\n      this.unbind();\n\n      this.resetPreview();\n      this.$preview = null;\n\n      this.$viewBox = null;\n      this.$cropBox = null;\n      this.$dragBox = null;\n      this.$canvas = null;\n      this.$container = null;\n\n      this.$cropper.remove();\n      this.$cropper = null;\n    },\n\n    render: function () {\n      this.initContainer();\n      this.initCanvas();\n      this.initCropBox();\n\n      this.renderCanvas();\n\n      if (this.isCropped) {\n        this.renderCropBox();\n      }\n    },\n\n    initContainer: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $container = this.$container;\n      var $cropper = this.$cropper;\n\n      $cropper.addClass(CLASS_HIDDEN);\n      $this.removeClass(CLASS_HIDDEN);\n\n      $cropper.css((this.container = {\n        width: max($container.width(), num(options.minContainerWidth) || 200),\n        height: max($container.height(), num(options.minContainerHeight) || 100)\n      }));\n\n      $this.addClass(CLASS_HIDDEN);\n      $cropper.removeClass(CLASS_HIDDEN);\n    },\n\n    // Canvas (image wrapper)\n    initCanvas: function () {\n      var viewMode = this.options.viewMode;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var image = this.image;\n      var imageNaturalWidth = image.naturalWidth;\n      var imageNaturalHeight = image.naturalHeight;\n      var is90Degree = abs(image.rotate) === 90;\n      var naturalWidth = is90Degree ? imageNaturalHeight : imageNaturalWidth;\n      var naturalHeight = is90Degree ? imageNaturalWidth : imageNaturalHeight;\n      var aspectRatio = naturalWidth / naturalHeight;\n      var canvasWidth = containerWidth;\n      var canvasHeight = containerHeight;\n      var canvas;\n\n      if (containerHeight * aspectRatio > containerWidth) {\n        if (viewMode === 3) {\n          canvasWidth = containerHeight * aspectRatio;\n        } else {\n          canvasHeight = containerWidth / aspectRatio;\n        }\n      } else {\n        if (viewMode === 3) {\n          canvasHeight = containerWidth / aspectRatio;\n        } else {\n          canvasWidth = containerHeight * aspectRatio;\n        }\n      }\n\n      canvas = {\n        naturalWidth: naturalWidth,\n        naturalHeight: naturalHeight,\n        aspectRatio: aspectRatio,\n        width: canvasWidth,\n        height: canvasHeight\n      };\n\n      canvas.oldLeft = canvas.left = (containerWidth - canvasWidth) / 2;\n      canvas.oldTop = canvas.top = (containerHeight - canvasHeight) / 2;\n\n      this.canvas = canvas;\n      this.isLimited = (viewMode === 1 || viewMode === 2);\n      this.limitCanvas(true, true);\n      this.initialImage = $.extend({}, image);\n      this.initialCanvas = $.extend({}, canvas);\n    },\n\n    limitCanvas: function (isSizeLimited, isPositionLimited) {\n      var options = this.options;\n      var viewMode = options.viewMode;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var canvas = this.canvas;\n      var aspectRatio = canvas.aspectRatio;\n      var cropBox = this.cropBox;\n      var isCropped = this.isCropped && cropBox;\n      var minCanvasWidth;\n      var minCanvasHeight;\n      var newCanvasLeft;\n      var newCanvasTop;\n\n      if (isSizeLimited) {\n        minCanvasWidth = num(options.minCanvasWidth) || 0;\n        minCanvasHeight = num(options.minCanvasHeight) || 0;\n\n        if (viewMode) {\n          if (viewMode > 1) {\n            minCanvasWidth = max(minCanvasWidth, containerWidth);\n            minCanvasHeight = max(minCanvasHeight, containerHeight);\n\n            if (viewMode === 3) {\n              if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                minCanvasWidth = minCanvasHeight * aspectRatio;\n              } else {\n                minCanvasHeight = minCanvasWidth / aspectRatio;\n              }\n            }\n          } else {\n            if (minCanvasWidth) {\n              minCanvasWidth = max(minCanvasWidth, isCropped ? cropBox.width : 0);\n            } else if (minCanvasHeight) {\n              minCanvasHeight = max(minCanvasHeight, isCropped ? cropBox.height : 0);\n            } else if (isCropped) {\n              minCanvasWidth = cropBox.width;\n              minCanvasHeight = cropBox.height;\n\n              if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n                minCanvasWidth = minCanvasHeight * aspectRatio;\n              } else {\n                minCanvasHeight = minCanvasWidth / aspectRatio;\n              }\n            }\n          }\n        }\n\n        if (minCanvasWidth && minCanvasHeight) {\n          if (minCanvasHeight * aspectRatio > minCanvasWidth) {\n            minCanvasHeight = minCanvasWidth / aspectRatio;\n          } else {\n            minCanvasWidth = minCanvasHeight * aspectRatio;\n          }\n        } else if (minCanvasWidth) {\n          minCanvasHeight = minCanvasWidth / aspectRatio;\n        } else if (minCanvasHeight) {\n          minCanvasWidth = minCanvasHeight * aspectRatio;\n        }\n\n        canvas.minWidth = minCanvasWidth;\n        canvas.minHeight = minCanvasHeight;\n        canvas.maxWidth = Infinity;\n        canvas.maxHeight = Infinity;\n      }\n\n      if (isPositionLimited) {\n        if (viewMode) {\n          newCanvasLeft = containerWidth - canvas.width;\n          newCanvasTop = containerHeight - canvas.height;\n\n          canvas.minLeft = min(0, newCanvasLeft);\n          canvas.minTop = min(0, newCanvasTop);\n          canvas.maxLeft = max(0, newCanvasLeft);\n          canvas.maxTop = max(0, newCanvasTop);\n\n          if (isCropped && this.isLimited) {\n            canvas.minLeft = min(\n              cropBox.left,\n              cropBox.left + cropBox.width - canvas.width\n            );\n            canvas.minTop = min(\n              cropBox.top,\n              cropBox.top + cropBox.height - canvas.height\n            );\n            canvas.maxLeft = cropBox.left;\n            canvas.maxTop = cropBox.top;\n\n            if (viewMode === 2) {\n              if (canvas.width >= containerWidth) {\n                canvas.minLeft = min(0, newCanvasLeft);\n                canvas.maxLeft = max(0, newCanvasLeft);\n              }\n\n              if (canvas.height >= containerHeight) {\n                canvas.minTop = min(0, newCanvasTop);\n                canvas.maxTop = max(0, newCanvasTop);\n              }\n            }\n          }\n        } else {\n          canvas.minLeft = -canvas.width;\n          canvas.minTop = -canvas.height;\n          canvas.maxLeft = containerWidth;\n          canvas.maxTop = containerHeight;\n        }\n      }\n    },\n\n    renderCanvas: function (isChanged) {\n      var canvas = this.canvas;\n      var image = this.image;\n      var rotate = image.rotate;\n      var naturalWidth = image.naturalWidth;\n      var naturalHeight = image.naturalHeight;\n      var aspectRatio;\n      var rotated;\n\n      if (this.isRotated) {\n        this.isRotated = false;\n\n        // Computes rotated sizes with image sizes\n        rotated = getRotatedSizes({\n          width: image.width,\n          height: image.height,\n          degree: rotate\n        });\n\n        aspectRatio = rotated.width / rotated.height;\n\n        if (aspectRatio !== canvas.aspectRatio) {\n          canvas.left -= (rotated.width - canvas.width) / 2;\n          canvas.top -= (rotated.height - canvas.height) / 2;\n          canvas.width = rotated.width;\n          canvas.height = rotated.height;\n          canvas.aspectRatio = aspectRatio;\n          canvas.naturalWidth = naturalWidth;\n          canvas.naturalHeight = naturalHeight;\n\n          // Computes rotated sizes with natural image sizes\n          if (rotate % 180) {\n            rotated = getRotatedSizes({\n              width: naturalWidth,\n              height: naturalHeight,\n              degree: rotate\n            });\n\n            canvas.naturalWidth = rotated.width;\n            canvas.naturalHeight = rotated.height;\n          }\n\n          this.limitCanvas(true, false);\n        }\n      }\n\n      if (canvas.width > canvas.maxWidth || canvas.width < canvas.minWidth) {\n        canvas.left = canvas.oldLeft;\n      }\n\n      if (canvas.height > canvas.maxHeight || canvas.height < canvas.minHeight) {\n        canvas.top = canvas.oldTop;\n      }\n\n      canvas.width = min(max(canvas.width, canvas.minWidth), canvas.maxWidth);\n      canvas.height = min(max(canvas.height, canvas.minHeight), canvas.maxHeight);\n\n      this.limitCanvas(false, true);\n\n      canvas.oldLeft = canvas.left = min(max(canvas.left, canvas.minLeft), canvas.maxLeft);\n      canvas.oldTop = canvas.top = min(max(canvas.top, canvas.minTop), canvas.maxTop);\n\n      this.$canvas.css({\n        width: canvas.width,\n        height: canvas.height,\n        left: canvas.left,\n        top: canvas.top\n      });\n\n      this.renderImage();\n\n      if (this.isCropped && this.isLimited) {\n        this.limitCropBox(true, true);\n      }\n\n      if (isChanged) {\n        this.output();\n      }\n    },\n\n    renderImage: function (isChanged) {\n      var canvas = this.canvas;\n      var image = this.image;\n      var reversed;\n\n      if (image.rotate) {\n        reversed = getRotatedSizes({\n          width: canvas.width,\n          height: canvas.height,\n          degree: image.rotate,\n          aspectRatio: image.aspectRatio\n        }, true);\n      }\n\n      $.extend(image, reversed ? {\n        width: reversed.width,\n        height: reversed.height,\n        left: (canvas.width - reversed.width) / 2,\n        top: (canvas.height - reversed.height) / 2\n      } : {\n        width: canvas.width,\n        height: canvas.height,\n        left: 0,\n        top: 0\n      });\n\n      this.$clone.css({\n        width: image.width,\n        height: image.height,\n        marginLeft: image.left,\n        marginTop: image.top,\n        transform: getTransform(image)\n      });\n\n      if (isChanged) {\n        this.output();\n      }\n    },\n\n    initCropBox: function () {\n      var options = this.options;\n      var canvas = this.canvas;\n      var aspectRatio = options.aspectRatio;\n      var autoCropArea = num(options.autoCropArea) || 0.8;\n      var cropBox = {\n            width: canvas.width,\n            height: canvas.height\n          };\n\n      if (aspectRatio) {\n        if (canvas.height * aspectRatio > canvas.width) {\n          cropBox.height = cropBox.width / aspectRatio;\n        } else {\n          cropBox.width = cropBox.height * aspectRatio;\n        }\n      }\n\n      this.cropBox = cropBox;\n      this.limitCropBox(true, true);\n\n      // Initialize auto crop area\n      cropBox.width = min(max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);\n      cropBox.height = min(max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);\n\n      // The width of auto crop area must large than \"minWidth\", and the height too. (#164)\n      cropBox.width = max(cropBox.minWidth, cropBox.width * autoCropArea);\n      cropBox.height = max(cropBox.minHeight, cropBox.height * autoCropArea);\n      cropBox.oldLeft = cropBox.left = canvas.left + (canvas.width - cropBox.width) / 2;\n      cropBox.oldTop = cropBox.top = canvas.top + (canvas.height - cropBox.height) / 2;\n\n      this.initialCropBox = $.extend({}, cropBox);\n    },\n\n    limitCropBox: function (isSizeLimited, isPositionLimited) {\n      var options = this.options;\n      var aspectRatio = options.aspectRatio;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var isLimited = this.isLimited;\n      var minCropBoxWidth;\n      var minCropBoxHeight;\n      var maxCropBoxWidth;\n      var maxCropBoxHeight;\n\n      if (isSizeLimited) {\n        minCropBoxWidth = num(options.minCropBoxWidth) || 0;\n        minCropBoxHeight = num(options.minCropBoxHeight) || 0;\n\n        // The min/maxCropBoxWidth/Height must be less than containerWidth/Height\n        minCropBoxWidth = min(minCropBoxWidth, containerWidth);\n        minCropBoxHeight = min(minCropBoxHeight, containerHeight);\n        maxCropBoxWidth = min(containerWidth, isLimited ? canvas.width : containerWidth);\n        maxCropBoxHeight = min(containerHeight, isLimited ? canvas.height : containerHeight);\n\n        if (aspectRatio) {\n          if (minCropBoxWidth && minCropBoxHeight) {\n            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {\n              minCropBoxHeight = minCropBoxWidth / aspectRatio;\n            } else {\n              minCropBoxWidth = minCropBoxHeight * aspectRatio;\n            }\n          } else if (minCropBoxWidth) {\n            minCropBoxHeight = minCropBoxWidth / aspectRatio;\n          } else if (minCropBoxHeight) {\n            minCropBoxWidth = minCropBoxHeight * aspectRatio;\n          }\n\n          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {\n            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;\n          } else {\n            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;\n          }\n        }\n\n        // The minWidth/Height must be less than maxWidth/Height\n        cropBox.minWidth = min(minCropBoxWidth, maxCropBoxWidth);\n        cropBox.minHeight = min(minCropBoxHeight, maxCropBoxHeight);\n        cropBox.maxWidth = maxCropBoxWidth;\n        cropBox.maxHeight = maxCropBoxHeight;\n      }\n\n      if (isPositionLimited) {\n        if (isLimited) {\n          cropBox.minLeft = max(0, canvas.left);\n          cropBox.minTop = max(0, canvas.top);\n          cropBox.maxLeft = min(containerWidth, canvas.left + canvas.width) - cropBox.width;\n          cropBox.maxTop = min(containerHeight, canvas.top + canvas.height) - cropBox.height;\n        } else {\n          cropBox.minLeft = 0;\n          cropBox.minTop = 0;\n          cropBox.maxLeft = containerWidth - cropBox.width;\n          cropBox.maxTop = containerHeight - cropBox.height;\n        }\n      }\n    },\n\n    renderCropBox: function () {\n      var options = this.options;\n      var container = this.container;\n      var containerWidth = container.width;\n      var containerHeight = container.height;\n      var cropBox = this.cropBox;\n\n      if (cropBox.width > cropBox.maxWidth || cropBox.width < cropBox.minWidth) {\n        cropBox.left = cropBox.oldLeft;\n      }\n\n      if (cropBox.height > cropBox.maxHeight || cropBox.height < cropBox.minHeight) {\n        cropBox.top = cropBox.oldTop;\n      }\n\n      cropBox.width = min(max(cropBox.width, cropBox.minWidth), cropBox.maxWidth);\n      cropBox.height = min(max(cropBox.height, cropBox.minHeight), cropBox.maxHeight);\n\n      this.limitCropBox(false, true);\n\n      cropBox.oldLeft = cropBox.left = min(max(cropBox.left, cropBox.minLeft), cropBox.maxLeft);\n      cropBox.oldTop = cropBox.top = min(max(cropBox.top, cropBox.minTop), cropBox.maxTop);\n\n      if (options.movable && options.cropBoxMovable) {\n\n        // Turn to move the canvas when the crop box is equal to the container\n        this.$face.data(DATA_ACTION, (cropBox.width === containerWidth && cropBox.height === containerHeight) ? ACTION_MOVE : ACTION_ALL);\n      }\n\n      this.$cropBox.css({\n        width: cropBox.width,\n        height: cropBox.height,\n        left: cropBox.left,\n        top: cropBox.top\n      });\n\n      if (this.isCropped && this.isLimited) {\n        this.limitCanvas(true, true);\n      }\n\n      if (!this.isDisabled) {\n        this.output();\n      }\n    },\n\n    output: function () {\n      this.preview();\n\n      if (this.isCompleted) {\n        this.trigger(EVENT_CROP, this.getData());\n      } else if (!this.isBuilt) {\n\n        // Only trigger one crop event before complete\n        this.$element.one(EVENT_BUILT, $.proxy(function () {\n          this.trigger(EVENT_CROP, this.getData());\n        }, this));\n      }\n    },\n\n    initPreview: function () {\n      var crossOrigin = getCrossOrigin(this.crossOrigin);\n      var url = crossOrigin ? this.crossOriginUrl : this.url;\n      var $clone2;\n\n      this.$preview = $(this.options.preview);\n      this.$clone2 = $clone2 = $('<img' + crossOrigin + ' src=\"' + url + '\">');\n      this.$viewBox.html($clone2);\n      this.$preview.each(function () {\n        var $this = $(this);\n\n        // Save the original size for recover\n        $this.data(DATA_PREVIEW, {\n          width: $this.width(),\n          height: $this.height(),\n          html: $this.html()\n        });\n\n        /**\n         * Override img element styles\n         * Add `display:block` to avoid margin top issue\n         * (Occur only when margin-top <= -height)\n         */\n        $this.html(\n          '<img' + crossOrigin + ' src=\"' + url + '\" style=\"' +\n          'display:block;width:100%;height:auto;' +\n          'min-width:0!important;min-height:0!important;' +\n          'max-width:none!important;max-height:none!important;' +\n          'image-orientation:0deg!important;\">'\n        );\n      });\n    },\n\n    resetPreview: function () {\n      this.$preview.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_PREVIEW);\n\n        $this.css({\n          width: data.width,\n          height: data.height\n        }).html(data.html).removeData(DATA_PREVIEW);\n      });\n    },\n\n    preview: function () {\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var cropBoxWidth = cropBox.width;\n      var cropBoxHeight = cropBox.height;\n      var width = image.width;\n      var height = image.height;\n      var left = cropBox.left - canvas.left - image.left;\n      var top = cropBox.top - canvas.top - image.top;\n\n      if (!this.isCropped || this.isDisabled) {\n        return;\n      }\n\n      this.$clone2.css({\n        width: width,\n        height: height,\n        marginLeft: -left,\n        marginTop: -top,\n        transform: getTransform(image)\n      });\n\n      this.$preview.each(function () {\n        var $this = $(this);\n        var data = $this.data(DATA_PREVIEW);\n        var originalWidth = data.width;\n        var originalHeight = data.height;\n        var newWidth = originalWidth;\n        var newHeight = originalHeight;\n        var ratio = 1;\n\n        if (cropBoxWidth) {\n          ratio = originalWidth / cropBoxWidth;\n          newHeight = cropBoxHeight * ratio;\n        }\n\n        if (cropBoxHeight && newHeight > originalHeight) {\n          ratio = originalHeight / cropBoxHeight;\n          newWidth = cropBoxWidth * ratio;\n          newHeight = originalHeight;\n        }\n\n        $this.css({\n          width: newWidth,\n          height: newHeight\n        }).find('img').css({\n          width: width * ratio,\n          height: height * ratio,\n          marginLeft: -left * ratio,\n          marginTop: -top * ratio,\n          transform: getTransform(image)\n        });\n      });\n    },\n\n    bind: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $cropper = this.$cropper;\n\n      if ($.isFunction(options.cropstart)) {\n        $this.on(EVENT_CROP_START, options.cropstart);\n      }\n\n      if ($.isFunction(options.cropmove)) {\n        $this.on(EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if ($.isFunction(options.cropend)) {\n        $this.on(EVENT_CROP_END, options.cropend);\n      }\n\n      if ($.isFunction(options.crop)) {\n        $this.on(EVENT_CROP, options.crop);\n      }\n\n      if ($.isFunction(options.zoom)) {\n        $this.on(EVENT_ZOOM, options.zoom);\n      }\n\n      $cropper.on(EVENT_MOUSE_DOWN, $.proxy(this.cropStart, this));\n\n      if (options.zoomable && options.zoomOnWheel) {\n        $cropper.on(EVENT_WHEEL, $.proxy(this.wheel, this));\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        $cropper.on(EVENT_DBLCLICK, $.proxy(this.dblclick, this));\n      }\n\n      $document.\n        on(EVENT_MOUSE_MOVE, (this._cropMove = proxy(this.cropMove, this))).\n        on(EVENT_MOUSE_UP, (this._cropEnd = proxy(this.cropEnd, this)));\n\n      if (options.responsive) {\n        $window.on(EVENT_RESIZE, (this._resize = proxy(this.resize, this)));\n      }\n    },\n\n    unbind: function () {\n      var options = this.options;\n      var $this = this.$element;\n      var $cropper = this.$cropper;\n\n      if ($.isFunction(options.cropstart)) {\n        $this.off(EVENT_CROP_START, options.cropstart);\n      }\n\n      if ($.isFunction(options.cropmove)) {\n        $this.off(EVENT_CROP_MOVE, options.cropmove);\n      }\n\n      if ($.isFunction(options.cropend)) {\n        $this.off(EVENT_CROP_END, options.cropend);\n      }\n\n      if ($.isFunction(options.crop)) {\n        $this.off(EVENT_CROP, options.crop);\n      }\n\n      if ($.isFunction(options.zoom)) {\n        $this.off(EVENT_ZOOM, options.zoom);\n      }\n\n      $cropper.off(EVENT_MOUSE_DOWN, this.cropStart);\n\n      if (options.zoomable && options.zoomOnWheel) {\n        $cropper.off(EVENT_WHEEL, this.wheel);\n      }\n\n      if (options.toggleDragModeOnDblclick) {\n        $cropper.off(EVENT_DBLCLICK, this.dblclick);\n      }\n\n      $document.\n        off(EVENT_MOUSE_MOVE, this._cropMove).\n        off(EVENT_MOUSE_UP, this._cropEnd);\n\n      if (options.responsive) {\n        $window.off(EVENT_RESIZE, this._resize);\n      }\n    },\n\n    resize: function () {\n      var restore = this.options.restore;\n      var $container = this.$container;\n      var container = this.container;\n      var canvasData;\n      var cropBoxData;\n      var ratio;\n\n      // Check `container` is necessary for IE8\n      if (this.isDisabled || !container) {\n        return;\n      }\n\n      ratio = $container.width() / container.width;\n\n      // Resize when width changed or height changed\n      if (ratio !== 1 || $container.height() !== container.height) {\n        if (restore) {\n          canvasData = this.getCanvasData();\n          cropBoxData = this.getCropBoxData();\n        }\n\n        this.render();\n\n        if (restore) {\n          this.setCanvasData($.each(canvasData, function (i, n) {\n            canvasData[i] = n * ratio;\n          }));\n          this.setCropBoxData($.each(cropBoxData, function (i, n) {\n            cropBoxData[i] = n * ratio;\n          }));\n        }\n      }\n    },\n\n    dblclick: function () {\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (this.$dragBox.hasClass(CLASS_CROP)) {\n        this.setDragMode(ACTION_MOVE);\n      } else {\n        this.setDragMode(ACTION_CROP);\n      }\n    },\n\n    wheel: function (event) {\n      var e = event.originalEvent || event;\n      var ratio = num(this.options.wheelZoomRatio) || 0.1;\n      var delta = 1;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      event.preventDefault();\n\n      // Limit wheel speed to prevent zoom too fast\n      if (this.wheeling) {\n        return;\n      }\n\n      this.wheeling = true;\n\n      setTimeout($.proxy(function () {\n        this.wheeling = false;\n      }, this), 50);\n\n      if (e.deltaY) {\n        delta = e.deltaY > 0 ? 1 : -1;\n      } else if (e.wheelDelta) {\n        delta = -e.wheelDelta / 120;\n      } else if (e.detail) {\n        delta = e.detail > 0 ? 1 : -1;\n      }\n\n      this.zoom(-delta * ratio, event);\n    },\n\n    cropStart: function (event) {\n      var options = this.options;\n      var originalEvent = event.originalEvent;\n      var touches = originalEvent && originalEvent.touches;\n      var e = event;\n      var touchesLength;\n      var action;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (touches) {\n        touchesLength = touches.length;\n\n        if (touchesLength > 1) {\n          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {\n            e = touches[1];\n            this.startX2 = e.pageX;\n            this.startY2 = e.pageY;\n            action = ACTION_ZOOM;\n          } else {\n            return;\n          }\n        }\n\n        e = touches[0];\n      }\n\n      action = action || $(e.target).data(DATA_ACTION);\n\n      if (REGEXP_ACTIONS.test(action)) {\n        if (this.trigger(EVENT_CROP_START, {\n          originalEvent: originalEvent,\n          action: action\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        event.preventDefault();\n\n        this.action = action;\n        this.cropping = false;\n\n        // IE8  has `event.pageX/Y`, but not `event.originalEvent.pageX/Y`\n        // IE10 has `event.originalEvent.pageX/Y`, but not `event.pageX/Y`\n        this.startX = e.pageX || originalEvent && originalEvent.pageX;\n        this.startY = e.pageY || originalEvent && originalEvent.pageY;\n\n        if (action === ACTION_CROP) {\n          this.cropping = true;\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n      }\n    },\n\n    cropMove: function (event) {\n      var options = this.options;\n      var originalEvent = event.originalEvent;\n      var touches = originalEvent && originalEvent.touches;\n      var e = event;\n      var action = this.action;\n      var touchesLength;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (touches) {\n        touchesLength = touches.length;\n\n        if (touchesLength > 1) {\n          if (options.zoomable && options.zoomOnTouch && touchesLength === 2) {\n            e = touches[1];\n            this.endX2 = e.pageX;\n            this.endY2 = e.pageY;\n          } else {\n            return;\n          }\n        }\n\n        e = touches[0];\n      }\n\n      if (action) {\n        if (this.trigger(EVENT_CROP_MOVE, {\n          originalEvent: originalEvent,\n          action: action\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        event.preventDefault();\n\n        this.endX = e.pageX || originalEvent && originalEvent.pageX;\n        this.endY = e.pageY || originalEvent && originalEvent.pageY;\n\n        this.change(e.shiftKey, action === ACTION_ZOOM ? event : null);\n      }\n    },\n\n    cropEnd: function (event) {\n      var originalEvent = event.originalEvent;\n      var action = this.action;\n\n      if (this.isDisabled) {\n        return;\n      }\n\n      if (action) {\n        event.preventDefault();\n\n        if (this.cropping) {\n          this.cropping = false;\n          this.$dragBox.toggleClass(CLASS_MODAL, this.isCropped && this.options.modal);\n        }\n\n        this.action = '';\n\n        this.trigger(EVENT_CROP_END, {\n          originalEvent: originalEvent,\n          action: action\n        });\n      }\n    },\n\n    change: function (shiftKey, event) {\n      var options = this.options;\n      var aspectRatio = options.aspectRatio;\n      var action = this.action;\n      var container = this.container;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var width = cropBox.width;\n      var height = cropBox.height;\n      var left = cropBox.left;\n      var top = cropBox.top;\n      var right = left + width;\n      var bottom = top + height;\n      var minLeft = 0;\n      var minTop = 0;\n      var maxWidth = container.width;\n      var maxHeight = container.height;\n      var renderable = true;\n      var offset;\n      var range;\n\n      // Locking aspect ratio in \"free mode\" by holding shift key (#259)\n      if (!aspectRatio && shiftKey) {\n        aspectRatio = width && height ? width / height : 1;\n      }\n\n      if (this.limited) {\n        minLeft = cropBox.minLeft;\n        minTop = cropBox.minTop;\n        maxWidth = minLeft + min(container.width, canvas.left + canvas.width);\n        maxHeight = minTop + min(container.height, canvas.top + canvas.height);\n      }\n\n      range = {\n        x: this.endX - this.startX,\n        y: this.endY - this.startY\n      };\n\n      if (aspectRatio) {\n        range.X = range.y * aspectRatio;\n        range.Y = range.x / aspectRatio;\n      }\n\n      switch (action) {\n        // Move crop box\n        case ACTION_ALL:\n          left += range.x;\n          top += range.y;\n          break;\n\n        // Resize crop box\n        case ACTION_EAST:\n          if (range.x >= 0 && (right >= maxWidth || aspectRatio &&\n            (top <= minTop || bottom >= maxHeight))) {\n\n            renderable = false;\n            break;\n          }\n\n          width += range.x;\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top -= range.Y / 2;\n          }\n\n          if (width < 0) {\n            action = ACTION_WEST;\n            width = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH:\n          if (range.y <= 0 && (top <= minTop || aspectRatio &&\n            (left <= minLeft || right >= maxWidth))) {\n\n            renderable = false;\n            break;\n          }\n\n          height -= range.y;\n          top += range.y;\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left += range.X / 2;\n          }\n\n          if (height < 0) {\n            action = ACTION_SOUTH;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_WEST:\n          if (range.x <= 0 && (left <= minLeft || aspectRatio &&\n            (top <= minTop || bottom >= maxHeight))) {\n\n            renderable = false;\n            break;\n          }\n\n          width -= range.x;\n          left += range.x;\n\n          if (aspectRatio) {\n            height = width / aspectRatio;\n            top += range.Y / 2;\n          }\n\n          if (width < 0) {\n            action = ACTION_EAST;\n            width = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH:\n          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio &&\n            (left <= minLeft || right >= maxWidth))) {\n\n            renderable = false;\n            break;\n          }\n\n          height += range.y;\n\n          if (aspectRatio) {\n            width = height * aspectRatio;\n            left -= range.X / 2;\n          }\n\n          if (height < 0) {\n            action = ACTION_NORTH;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH_EAST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {\n              renderable = false;\n              break;\n            }\n\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n          } else {\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_NORTH_WEST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_NORTH_WEST:\n          if (aspectRatio) {\n            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {\n              renderable = false;\n              break;\n            }\n\n            height -= range.y;\n            top += range.y;\n            width = height * aspectRatio;\n            left += range.X;\n          } else {\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y <= 0 && top <= minTop) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y <= 0) {\n              if (top > minTop) {\n                height -= range.y;\n                top += range.y;\n              }\n            } else {\n              height -= range.y;\n              top += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_SOUTH_EAST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_NORTH_EAST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_SOUTH_WEST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH_WEST:\n          if (aspectRatio) {\n            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            width -= range.x;\n            left += range.x;\n            height = width / aspectRatio;\n          } else {\n            if (range.x <= 0) {\n              if (left > minLeft) {\n                width -= range.x;\n                left += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width -= range.x;\n              left += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_EAST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = 0;\n          }\n\n          break;\n\n        case ACTION_SOUTH_EAST:\n          if (aspectRatio) {\n            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {\n              renderable = false;\n              break;\n            }\n\n            width += range.x;\n            height = width / aspectRatio;\n          } else {\n            if (range.x >= 0) {\n              if (right < maxWidth) {\n                width += range.x;\n              } else if (range.y >= 0 && bottom >= maxHeight) {\n                renderable = false;\n              }\n            } else {\n              width += range.x;\n            }\n\n            if (range.y >= 0) {\n              if (bottom < maxHeight) {\n                height += range.y;\n              }\n            } else {\n              height += range.y;\n            }\n          }\n\n          if (width < 0 && height < 0) {\n            action = ACTION_NORTH_WEST;\n            height = 0;\n            width = 0;\n          } else if (width < 0) {\n            action = ACTION_SOUTH_WEST;\n            width = 0;\n          } else if (height < 0) {\n            action = ACTION_NORTH_EAST;\n            height = 0;\n          }\n\n          break;\n\n        // Move canvas\n        case ACTION_MOVE:\n          this.move(range.x, range.y);\n          renderable = false;\n          break;\n\n        // Zoom canvas\n        case ACTION_ZOOM:\n          this.zoom((function (x1, y1, x2, y2) {\n            var z1 = sqrt(x1 * x1 + y1 * y1);\n            var z2 = sqrt(x2 * x2 + y2 * y2);\n\n            return (z2 - z1) / z1;\n          })(\n            abs(this.startX - this.startX2),\n            abs(this.startY - this.startY2),\n            abs(this.endX - this.endX2),\n            abs(this.endY - this.endY2)\n          ), event);\n          this.startX2 = this.endX2;\n          this.startY2 = this.endY2;\n          renderable = false;\n          break;\n\n        // Create crop box\n        case ACTION_CROP:\n          if (!range.x || !range.y) {\n            renderable = false;\n            break;\n          }\n\n          offset = this.$cropper.offset();\n          left = this.startX - offset.left;\n          top = this.startY - offset.top;\n          width = cropBox.minWidth;\n          height = cropBox.minHeight;\n\n          if (range.x > 0) {\n            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;\n          } else if (range.x < 0) {\n            left -= width;\n            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;\n          }\n\n          if (range.y < 0) {\n            top -= height;\n          }\n\n          // Show the crop box if is hidden\n          if (!this.isCropped) {\n            this.$cropBox.removeClass(CLASS_HIDDEN);\n            this.isCropped = true;\n\n            if (this.limited) {\n              this.limitCropBox(true, true);\n            }\n          }\n\n          break;\n\n        // No default\n      }\n\n      if (renderable) {\n        cropBox.width = width;\n        cropBox.height = height;\n        cropBox.left = left;\n        cropBox.top = top;\n        this.action = action;\n\n        this.renderCropBox();\n      }\n\n      // Override\n      this.startX = this.endX;\n      this.startY = this.endY;\n    },\n\n    // Show the crop box manually\n    crop: function () {\n      if (!this.isBuilt || this.isDisabled) {\n        return;\n      }\n\n      if (!this.isCropped) {\n        this.isCropped = true;\n        this.limitCropBox(true, true);\n\n        if (this.options.modal) {\n          this.$dragBox.addClass(CLASS_MODAL);\n        }\n\n        this.$cropBox.removeClass(CLASS_HIDDEN);\n      }\n\n      this.setCropBoxData(this.initialCropBox);\n    },\n\n    // Reset the image and crop box to their initial states\n    reset: function () {\n      if (!this.isBuilt || this.isDisabled) {\n        return;\n      }\n\n      this.image = $.extend({}, this.initialImage);\n      this.canvas = $.extend({}, this.initialCanvas);\n      this.cropBox = $.extend({}, this.initialCropBox);\n\n      this.renderCanvas();\n\n      if (this.isCropped) {\n        this.renderCropBox();\n      }\n    },\n\n    // Clear the crop box\n    clear: function () {\n      if (!this.isCropped || this.isDisabled) {\n        return;\n      }\n\n      $.extend(this.cropBox, {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0\n      });\n\n      this.isCropped = false;\n      this.renderCropBox();\n\n      this.limitCanvas(true, true);\n\n      // Render canvas after crop box rendered\n      this.renderCanvas();\n\n      this.$dragBox.removeClass(CLASS_MODAL);\n      this.$cropBox.addClass(CLASS_HIDDEN);\n    },\n\n    /**\n     * Replace the image's src and rebuild the cropper\n     *\n     * @param {String} url\n     * @param {Boolean} onlyColorChanged (optional)\n     */\n    replace: function (url, onlyColorChanged) {\n      if (!this.isDisabled && url) {\n        if (this.isImg) {\n          this.$element.attr('src', url);\n        }\n\n        if (onlyColorChanged) {\n          this.url = url;\n          this.$clone.attr('src', url);\n\n          if (this.isBuilt) {\n            this.$preview.find('img').add(this.$clone2).attr('src', url);\n          }\n        } else {\n          if (this.isImg) {\n            this.isReplaced = true;\n          }\n\n          // Clear previous data\n          this.options.data = null;\n          this.load(url);\n        }\n      }\n    },\n\n    // Enable (unfreeze) the cropper\n    enable: function () {\n      if (this.isBuilt) {\n        this.isDisabled = false;\n        this.$cropper.removeClass(CLASS_DISABLED);\n      }\n    },\n\n    // Disable (freeze) the cropper\n    disable: function () {\n      if (this.isBuilt) {\n        this.isDisabled = true;\n        this.$cropper.addClass(CLASS_DISABLED);\n      }\n    },\n\n    // Destroy the cropper and remove the instance from the image\n    destroy: function () {\n      var $this = this.$element;\n\n      if (this.isLoaded) {\n        if (this.isImg && this.isReplaced) {\n          $this.attr('src', this.originalUrl);\n        }\n\n        this.unbuild();\n        $this.removeClass(CLASS_HIDDEN);\n      } else {\n        if (this.isImg) {\n          $this.off(EVENT_LOAD, this.start);\n        } else if (this.$clone) {\n          this.$clone.remove();\n        }\n      }\n\n      $this.removeData(NAMESPACE);\n    },\n\n    /**\n     * Move the canvas with relative offsets\n     *\n     * @param {Number} offsetX\n     * @param {Number} offsetY (optional)\n     */\n    move: function (offsetX, offsetY) {\n      var canvas = this.canvas;\n\n      this.moveTo(\n        isUndefined(offsetX) ? offsetX : canvas.left + num(offsetX),\n        isUndefined(offsetY) ? offsetY : canvas.top + num(offsetY)\n      );\n    },\n\n    /**\n     * Move the canvas to an absolute point\n     *\n     * @param {Number} x\n     * @param {Number} y (optional)\n     */\n    moveTo: function (x, y) {\n      var canvas = this.canvas;\n      var isChanged = false;\n\n      // If \"y\" is not present, its default value is \"x\"\n      if (isUndefined(y)) {\n        y = x;\n      }\n\n      x = num(x);\n      y = num(y);\n\n      if (this.isBuilt && !this.isDisabled && this.options.movable) {\n        if (isNumber(x)) {\n          canvas.left = x;\n          isChanged = true;\n        }\n\n        if (isNumber(y)) {\n          canvas.top = y;\n          isChanged = true;\n        }\n\n        if (isChanged) {\n          this.renderCanvas(true);\n        }\n      }\n    },\n\n    /**\n     * Zoom the canvas with a relative ratio\n     *\n     * @param {Number} ratio\n     * @param {jQuery Event} _event (private)\n     */\n    zoom: function (ratio, _event) {\n      var canvas = this.canvas;\n\n      ratio = num(ratio);\n\n      if (ratio < 0) {\n        ratio =  1 / (1 - ratio);\n      } else {\n        ratio = 1 + ratio;\n      }\n\n      this.zoomTo(canvas.width * ratio / canvas.naturalWidth, _event);\n    },\n\n    /**\n     * Zoom the canvas to an absolute ratio\n     *\n     * @param {Number} ratio\n     * @param {jQuery Event} _event (private)\n     */\n    zoomTo: function (ratio, _event) {\n      var options = this.options;\n      var canvas = this.canvas;\n      var width = canvas.width;\n      var height = canvas.height;\n      var naturalWidth = canvas.naturalWidth;\n      var naturalHeight = canvas.naturalHeight;\n      var originalEvent;\n      var newWidth;\n      var newHeight;\n      var offset;\n      var center;\n\n      ratio = num(ratio);\n\n      if (ratio >= 0 && this.isBuilt && !this.isDisabled && options.zoomable) {\n        newWidth = naturalWidth * ratio;\n        newHeight = naturalHeight * ratio;\n\n        if (_event) {\n          originalEvent = _event.originalEvent;\n        }\n\n        if (this.trigger(EVENT_ZOOM, {\n          originalEvent: originalEvent,\n          oldRatio: width / naturalWidth,\n          ratio: newWidth / naturalWidth\n        }).isDefaultPrevented()) {\n          return;\n        }\n\n        if (originalEvent) {\n          offset = this.$cropper.offset();\n          center = originalEvent.touches ? getTouchesCenter(originalEvent.touches) : {\n            pageX: _event.pageX || originalEvent.pageX || 0,\n            pageY: _event.pageY || originalEvent.pageY || 0\n          };\n\n          // Zoom from the triggering point of the event\n          canvas.left -= (newWidth - width) * (\n            ((center.pageX - offset.left) - canvas.left) / width\n          );\n          canvas.top -= (newHeight - height) * (\n            ((center.pageY - offset.top) - canvas.top) / height\n          );\n        } else {\n\n          // Zoom from the center of the canvas\n          canvas.left -= (newWidth - width) / 2;\n          canvas.top -= (newHeight - height) / 2;\n        }\n\n        canvas.width = newWidth;\n        canvas.height = newHeight;\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Rotate the canvas with a relative degree\n     *\n     * @param {Number} degree\n     */\n    rotate: function (degree) {\n      this.rotateTo((this.image.rotate || 0) + num(degree));\n    },\n\n    /**\n     * Rotate the canvas to an absolute degree\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#rotate()\n     *\n     * @param {Number} degree\n     */\n    rotateTo: function (degree) {\n      degree = num(degree);\n\n      if (isNumber(degree) && this.isBuilt && !this.isDisabled && this.options.rotatable) {\n        this.image.rotate = degree % 360;\n        this.isRotated = true;\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Scale the image\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#scale()\n     *\n     * @param {Number} scaleX\n     * @param {Number} scaleY (optional)\n     */\n    scale: function (scaleX, scaleY) {\n      var image = this.image;\n      var isChanged = false;\n\n      // If \"scaleY\" is not present, its default value is \"scaleX\"\n      if (isUndefined(scaleY)) {\n        scaleY = scaleX;\n      }\n\n      scaleX = num(scaleX);\n      scaleY = num(scaleY);\n\n      if (this.isBuilt && !this.isDisabled && this.options.scalable) {\n        if (isNumber(scaleX)) {\n          image.scaleX = scaleX;\n          isChanged = true;\n        }\n\n        if (isNumber(scaleY)) {\n          image.scaleY = scaleY;\n          isChanged = true;\n        }\n\n        if (isChanged) {\n          this.renderImage(true);\n        }\n      }\n    },\n\n    /**\n     * Scale the abscissa of the image\n     *\n     * @param {Number} scaleX\n     */\n    scaleX: function (scaleX) {\n      var scaleY = this.image.scaleY;\n\n      this.scale(scaleX, isNumber(scaleY) ? scaleY : 1);\n    },\n\n    /**\n     * Scale the ordinate of the image\n     *\n     * @param {Number} scaleY\n     */\n    scaleY: function (scaleY) {\n      var scaleX = this.image.scaleX;\n\n      this.scale(isNumber(scaleX) ? scaleX : 1, scaleY);\n    },\n\n    /**\n     * Get the cropped area position and size data (base on the original image)\n     *\n     * @param {Boolean} isRounded (optional)\n     * @return {Object} data\n     */\n    getData: function (isRounded) {\n      var options = this.options;\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBox = this.cropBox;\n      var ratio;\n      var data;\n\n      if (this.isBuilt && this.isCropped) {\n        data = {\n          x: cropBox.left - canvas.left,\n          y: cropBox.top - canvas.top,\n          width: cropBox.width,\n          height: cropBox.height\n        };\n\n        ratio = image.width / image.naturalWidth;\n\n        $.each(data, function (i, n) {\n          n = n / ratio;\n          data[i] = isRounded ? round(n) : n;\n        });\n\n      } else {\n        data = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n      }\n\n      if (options.rotatable) {\n        data.rotate = image.rotate || 0;\n      }\n\n      if (options.scalable) {\n        data.scaleX = image.scaleX || 1;\n        data.scaleY = image.scaleY || 1;\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the cropped area position and size with new data\n     *\n     * @param {Object} data\n     */\n    setData: function (data) {\n      var options = this.options;\n      var image = this.image;\n      var canvas = this.canvas;\n      var cropBoxData = {};\n      var isRotated;\n      var isScaled;\n      var ratio;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.element);\n      }\n\n      if (this.isBuilt && !this.isDisabled && $.isPlainObject(data)) {\n        if (options.rotatable) {\n          if (isNumber(data.rotate) && data.rotate !== image.rotate) {\n            image.rotate = data.rotate;\n            this.isRotated = isRotated = true;\n          }\n        }\n\n        if (options.scalable) {\n          if (isNumber(data.scaleX) && data.scaleX !== image.scaleX) {\n            image.scaleX = data.scaleX;\n            isScaled = true;\n          }\n\n          if (isNumber(data.scaleY) && data.scaleY !== image.scaleY) {\n            image.scaleY = data.scaleY;\n            isScaled = true;\n          }\n        }\n\n        if (isRotated) {\n          this.renderCanvas();\n        } else if (isScaled) {\n          this.renderImage();\n        }\n\n        ratio = image.width / image.naturalWidth;\n\n        if (isNumber(data.x)) {\n          cropBoxData.left = data.x * ratio + canvas.left;\n        }\n\n        if (isNumber(data.y)) {\n          cropBoxData.top = data.y * ratio + canvas.top;\n        }\n\n        if (isNumber(data.width)) {\n          cropBoxData.width = data.width * ratio;\n        }\n\n        if (isNumber(data.height)) {\n          cropBoxData.height = data.height * ratio;\n        }\n\n        this.setCropBoxData(cropBoxData);\n      }\n    },\n\n    /**\n     * Get the container size data\n     *\n     * @return {Object} data\n     */\n    getContainerData: function () {\n      return this.isBuilt ? this.container : {};\n    },\n\n    /**\n     * Get the image position and size data\n     *\n     * @return {Object} data\n     */\n    getImageData: function () {\n      return this.isLoaded ? this.image : {};\n    },\n\n    /**\n     * Get the canvas position and size data\n     *\n     * @return {Object} data\n     */\n    getCanvasData: function () {\n      var canvas = this.canvas;\n      var data = {};\n\n      if (this.isBuilt) {\n        $.each([\n          'left',\n          'top',\n          'width',\n          'height',\n          'naturalWidth',\n          'naturalHeight'\n        ], function (i, n) {\n          data[n] = canvas[n];\n        });\n      }\n\n      return data;\n    },\n\n    /**\n     * Set the canvas position and size with new data\n     *\n     * @param {Object} data\n     */\n    setCanvasData: function (data) {\n      var canvas = this.canvas;\n      var aspectRatio = canvas.aspectRatio;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.$element);\n      }\n\n      if (this.isBuilt && !this.isDisabled && $.isPlainObject(data)) {\n        if (isNumber(data.left)) {\n          canvas.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          canvas.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          canvas.width = data.width;\n          canvas.height = data.width / aspectRatio;\n        } else if (isNumber(data.height)) {\n          canvas.height = data.height;\n          canvas.width = data.height * aspectRatio;\n        }\n\n        this.renderCanvas(true);\n      }\n    },\n\n    /**\n     * Get the crop box position and size data\n     *\n     * @return {Object} data\n     */\n    getCropBoxData: function () {\n      var cropBox = this.cropBox;\n      var data;\n\n      if (this.isBuilt && this.isCropped) {\n        data = {\n          left: cropBox.left,\n          top: cropBox.top,\n          width: cropBox.width,\n          height: cropBox.height\n        };\n      }\n\n      return data || {};\n    },\n\n    /**\n     * Set the crop box position and size with new data\n     *\n     * @param {Object} data\n     */\n    setCropBoxData: function (data) {\n      var cropBox = this.cropBox;\n      var aspectRatio = this.options.aspectRatio;\n      var isWidthChanged;\n      var isHeightChanged;\n\n      if ($.isFunction(data)) {\n        data = data.call(this.$element);\n      }\n\n      if (this.isBuilt && this.isCropped && !this.isDisabled && $.isPlainObject(data)) {\n\n        if (isNumber(data.left)) {\n          cropBox.left = data.left;\n        }\n\n        if (isNumber(data.top)) {\n          cropBox.top = data.top;\n        }\n\n        if (isNumber(data.width)) {\n          isWidthChanged = true;\n          cropBox.width = data.width;\n        }\n\n        if (isNumber(data.height)) {\n          isHeightChanged = true;\n          cropBox.height = data.height;\n        }\n\n        if (aspectRatio) {\n          if (isWidthChanged) {\n            cropBox.height = cropBox.width / aspectRatio;\n          } else if (isHeightChanged) {\n            cropBox.width = cropBox.height * aspectRatio;\n          }\n        }\n\n        this.renderCropBox();\n      }\n    },\n\n    /**\n     * Get a canvas drawn the cropped image\n     *\n     * @param {Object} options (optional)\n     * @return {HTMLCanvasElement} canvas\n     */\n    getCroppedCanvas: function (options) {\n      var originalWidth;\n      var originalHeight;\n      var canvasWidth;\n      var canvasHeight;\n      var scaledWidth;\n      var scaledHeight;\n      var scaledRatio;\n      var aspectRatio;\n      var canvas;\n      var context;\n      var data;\n\n      if (!this.isBuilt || !this.isCropped || !SUPPORT_CANVAS) {\n        return;\n      }\n\n      if (!$.isPlainObject(options)) {\n        options = {};\n      }\n\n      data = this.getData();\n      originalWidth = data.width;\n      originalHeight = data.height;\n      aspectRatio = originalWidth / originalHeight;\n\n      if ($.isPlainObject(options)) {\n        scaledWidth = options.width;\n        scaledHeight = options.height;\n\n        if (scaledWidth) {\n          scaledHeight = scaledWidth / aspectRatio;\n          scaledRatio = scaledWidth / originalWidth;\n        } else if (scaledHeight) {\n          scaledWidth = scaledHeight * aspectRatio;\n          scaledRatio = scaledHeight / originalHeight;\n        }\n      }\n\n      // The canvas element will use `Math.floor` on a float number, so floor first\n      canvasWidth = floor(scaledWidth || originalWidth);\n      canvasHeight = floor(scaledHeight || originalHeight);\n\n      canvas = $('<canvas>')[0];\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n      context = canvas.getContext('2d');\n\n      if (options.fillColor) {\n        context.fillStyle = options.fillColor;\n        context.fillRect(0, 0, canvasWidth, canvasHeight);\n      }\n\n      // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage\n      context.drawImage.apply(context, (function () {\n        var source = getSourceCanvas(this.$clone[0], this.image);\n        var sourceWidth = source.width;\n        var sourceHeight = source.height;\n        var canvas = this.canvas;\n        var params = [source];\n\n        // Source canvas\n        var srcX = data.x + canvas.naturalWidth * (abs(data.scaleX || 1) - 1) / 2;\n        var srcY = data.y + canvas.naturalHeight * (abs(data.scaleY || 1) - 1) / 2;\n        var srcWidth;\n        var srcHeight;\n\n        // Destination canvas\n        var dstX;\n        var dstY;\n        var dstWidth;\n        var dstHeight;\n\n        if (srcX <= -originalWidth || srcX > sourceWidth) {\n          srcX = srcWidth = dstX = dstWidth = 0;\n        } else if (srcX <= 0) {\n          dstX = -srcX;\n          srcX = 0;\n          srcWidth = dstWidth = min(sourceWidth, originalWidth + srcX);\n        } else if (srcX <= sourceWidth) {\n          dstX = 0;\n          srcWidth = dstWidth = min(originalWidth, sourceWidth - srcX);\n        }\n\n        if (srcWidth <= 0 || srcY <= -originalHeight || srcY > sourceHeight) {\n          srcY = srcHeight = dstY = dstHeight = 0;\n        } else if (srcY <= 0) {\n          dstY = -srcY;\n          srcY = 0;\n          srcHeight = dstHeight = min(sourceHeight, originalHeight + srcY);\n        } else if (srcY <= sourceHeight) {\n          dstY = 0;\n          srcHeight = dstHeight = min(originalHeight, sourceHeight - srcY);\n        }\n\n        // All the numerical parameters should be integer for `drawImage` (#476)\n        params.push(floor(srcX), floor(srcY), floor(srcWidth), floor(srcHeight));\n\n        // Scale destination sizes\n        if (scaledRatio) {\n          dstX *= scaledRatio;\n          dstY *= scaledRatio;\n          dstWidth *= scaledRatio;\n          dstHeight *= scaledRatio;\n        }\n\n        // Avoid \"IndexSizeError\" in IE and Firefox\n        if (dstWidth > 0 && dstHeight > 0) {\n          params.push(floor(dstX), floor(dstY), floor(dstWidth), floor(dstHeight));\n        }\n\n        return params;\n      }).call(this));\n\n      return canvas;\n    },\n\n    /**\n     * Change the aspect ratio of the crop box\n     *\n     * @param {Number} aspectRatio\n     */\n    setAspectRatio: function (aspectRatio) {\n      var options = this.options;\n\n      if (!this.isDisabled && !isUndefined(aspectRatio)) {\n\n        // 0 -> NaN\n        options.aspectRatio = max(0, aspectRatio) || NaN;\n\n        if (this.isBuilt) {\n          this.initCropBox();\n\n          if (this.isCropped) {\n            this.renderCropBox();\n          }\n        }\n      }\n    },\n\n    /**\n     * Change the drag mode\n     *\n     * @param {String} mode (optional)\n     */\n    setDragMode: function (mode) {\n      var options = this.options;\n      var croppable;\n      var movable;\n\n      if (this.isLoaded && !this.isDisabled) {\n        croppable = mode === ACTION_CROP;\n        movable = options.movable && mode === ACTION_MOVE;\n        mode = (croppable || movable) ? mode : ACTION_NONE;\n\n        this.$dragBox.\n          data(DATA_ACTION, mode).\n          toggleClass(CLASS_CROP, croppable).\n          toggleClass(CLASS_MOVE, movable);\n\n        if (!options.cropBoxMovable) {\n\n          // Sync drag mode to crop box when it is not movable(#300)\n          this.$face.\n            data(DATA_ACTION, mode).\n            toggleClass(CLASS_CROP, croppable).\n            toggleClass(CLASS_MOVE, movable);\n        }\n      }\n    }\n  };\n\n  Cropper.DEFAULTS = {\n\n    // Define the view mode of the cropper\n    viewMode: 0, // 0, 1, 2, 3\n\n    // Define the dragging mode of the cropper\n    dragMode: 'crop', // 'crop', 'move' or 'none'\n\n    // Define the aspect ratio of the crop box\n    aspectRatio: NaN,\n\n    // An object with the previous cropping result data\n    data: null,\n\n    // A jQuery selector for adding extra containers to preview\n    preview: '',\n\n    // Re-render the cropper when resize the window\n    responsive: true,\n\n    // Restore the cropped area after resize the window\n    restore: true,\n\n    // Check if the current image is a cross-origin image\n    checkCrossOrigin: true,\n\n    // Check the current image's Exif Orientation information\n    checkOrientation: true,\n\n    // Show the black modal\n    modal: true,\n\n    // Show the dashed lines for guiding\n    guides: true,\n\n    // Show the center indicator for guiding\n    center: true,\n\n    // Show the white modal to highlight the crop box\n    highlight: true,\n\n    // Show the grid background\n    background: true,\n\n    // Enable to crop the image automatically when initialize\n    autoCrop: true,\n\n    // Define the percentage of automatic cropping area when initializes\n    autoCropArea: 0.8,\n\n    // Enable to move the image\n    movable: true,\n\n    // Enable to rotate the image\n    rotatable: true,\n\n    // Enable to scale the image\n    scalable: true,\n\n    // Enable to zoom the image\n    zoomable: true,\n\n    // Enable to zoom the image by dragging touch\n    zoomOnTouch: true,\n\n    // Enable to zoom the image by wheeling mouse\n    zoomOnWheel: true,\n\n    // Define zoom ratio when zoom the image by wheeling mouse\n    wheelZoomRatio: 0.1,\n\n    // Enable to move the crop box\n    cropBoxMovable: true,\n\n    // Enable to resize the crop box\n    cropBoxResizable: true,\n\n    // Toggle drag mode between \"crop\" and \"move\" when click twice on the cropper\n    toggleDragModeOnDblclick: true,\n\n    // Size limitation\n    minCanvasWidth: 0,\n    minCanvasHeight: 0,\n    minCropBoxWidth: 0,\n    minCropBoxHeight: 0,\n    minContainerWidth: 200,\n    minContainerHeight: 100,\n\n    // Shortcuts of events\n    build: null,\n    built: null,\n    cropstart: null,\n    cropmove: null,\n    cropend: null,\n    crop: null,\n    zoom: null\n  };\n\n  Cropper.setDefaults = function (options) {\n    $.extend(Cropper.DEFAULTS, options);\n  };\n\n  Cropper.TEMPLATE = (\n    '<div class=\"cropper-container\">' +\n      '<div class=\"cropper-wrap-box\">' +\n        '<div class=\"cropper-canvas\"></div>' +\n      '</div>' +\n      '<div class=\"cropper-drag-box\"></div>' +\n      '<div class=\"cropper-crop-box\">' +\n        '<span class=\"cropper-view-box\"></span>' +\n        '<span class=\"cropper-dashed dashed-h\"></span>' +\n        '<span class=\"cropper-dashed dashed-v\"></span>' +\n        '<span class=\"cropper-center\"></span>' +\n        '<span class=\"cropper-face\"></span>' +\n        '<span class=\"cropper-line line-e\" data-action=\"e\"></span>' +\n        '<span class=\"cropper-line line-n\" data-action=\"n\"></span>' +\n        '<span class=\"cropper-line line-w\" data-action=\"w\"></span>' +\n        '<span class=\"cropper-line line-s\" data-action=\"s\"></span>' +\n        '<span class=\"cropper-point point-e\" data-action=\"e\"></span>' +\n        '<span class=\"cropper-point point-n\" data-action=\"n\"></span>' +\n        '<span class=\"cropper-point point-w\" data-action=\"w\"></span>' +\n        '<span class=\"cropper-point point-s\" data-action=\"s\"></span>' +\n        '<span class=\"cropper-point point-ne\" data-action=\"ne\"></span>' +\n        '<span class=\"cropper-point point-nw\" data-action=\"nw\"></span>' +\n        '<span class=\"cropper-point point-sw\" data-action=\"sw\"></span>' +\n        '<span class=\"cropper-point point-se\" data-action=\"se\"></span>' +\n      '</div>' +\n    '</div>'\n  );\n\n  // Save the other cropper\n  Cropper.other = $.fn.cropper;\n\n  // Register as jQuery plugin\n  $.fn.cropper = function (option) {\n    var args = toArray(arguments, 1);\n    var result;\n\n    this.each(function () {\n      var $this = $(this);\n      var data = $this.data(NAMESPACE);\n      var options;\n      var fn;\n\n      if (!data) {\n        if (/destroy/.test(option)) {\n          return;\n        }\n\n        options = $.extend({}, $this.data(), $.isPlainObject(option) && option);\n        $this.data(NAMESPACE, (data = new Cropper(this, options)));\n      }\n\n      if (typeof option === 'string' && $.isFunction(fn = data[option])) {\n        result = fn.apply(data, args);\n      }\n    });\n\n    return isUndefined(result) ? this : result;\n  };\n\n  $.fn.cropper.Constructor = Cropper;\n  $.fn.cropper.setDefaults = Cropper.setDefaults;\n\n  // No conflict\n  $.fn.cropper.noConflict = function () {\n    $.fn.cropper = Cropper.other;\n    return this;\n  };\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /var/cache/omnibus/src/gitlab-rails/vendor/assets/javascripts/cropper.js\n// module id = ../../../vendor/assets/javascripts/cropper.js\n// module chunks = profile","/* eslint-disable no-useless-escape, max-len, quotes, no-var, no-underscore-dangle, func-names, space-before-function-paren, no-unused-vars, no-return-assign, object-shorthand, one-var, one-var-declaration-per-line, comma-dangle, consistent-return, class-methods-use-this, new-parens */\n\nimport 'vendor/cropper';\n\n((global) => {\n  // Matches everything but the file name\n  const FILENAMEREGEX = /^.*[\\\\\\/]/;\n\n  class GitLabCrop {\n    constructor(input, { filename, previewImage, modalCrop, pickImageEl, uploadImageBtn, modalCropImg,\n        exportWidth = 200, exportHeight = 200, cropBoxWidth = 200, cropBoxHeight = 200 } = {}) {\n      this.onUploadImageBtnClick = this.onUploadImageBtnClick.bind(this);\n      this.onModalHide = this.onModalHide.bind(this);\n      this.onModalShow = this.onModalShow.bind(this);\n      this.onPickImageClick = this.onPickImageClick.bind(this);\n      this.fileInput = $(input);\n      this.modalCropImg = _.isString(this.modalCropImg) ? $(this.modalCropImg) : this.modalCropImg;\n      this.fileInput.attr('name', `${this.fileInput.attr('name')}-trigger`).attr('id', `${this.fileInput.attr('id')}-trigger`);\n      this.exportWidth = exportWidth;\n      this.exportHeight = exportHeight;\n      this.cropBoxWidth = cropBoxWidth;\n      this.cropBoxHeight = cropBoxHeight;\n      this.form = this.fileInput.parents('form');\n      this.filename = filename;\n      this.previewImage = previewImage;\n      this.modalCrop = modalCrop;\n      this.pickImageEl = pickImageEl;\n      this.uploadImageBtn = uploadImageBtn;\n      this.modalCropImg = modalCropImg;\n      this.filename = this.getElement(filename);\n      this.previewImage = this.getElement(previewImage);\n      this.pickImageEl = this.getElement(pickImageEl);\n      this.modalCrop = _.isString(modalCrop) ? $(modalCrop) : modalCrop;\n      this.uploadImageBtn = _.isString(uploadImageBtn) ? $(uploadImageBtn) : uploadImageBtn;\n      this.modalCropImg = _.isString(modalCropImg) ? $(modalCropImg) : modalCropImg;\n      this.cropActionsBtn = this.modalCrop.find('[data-method]');\n      this.bindEvents();\n    }\n\n    getElement(selector) {\n      return $(selector, this.form);\n    }\n\n    bindEvents() {\n      var _this;\n      _this = this;\n      this.fileInput.on('change', function(e) {\n        return _this.onFileInputChange(e, this);\n      });\n      this.pickImageEl.on('click', this.onPickImageClick);\n      this.modalCrop.on('shown.bs.modal', this.onModalShow);\n      this.modalCrop.on('hidden.bs.modal', this.onModalHide);\n      this.uploadImageBtn.on('click', this.onUploadImageBtnClick);\n      this.cropActionsBtn.on('click', function(e) {\n        var btn;\n        btn = this;\n        return _this.onActionBtnClick(btn);\n      });\n      return this.croppedImageBlob = null;\n    }\n\n    onPickImageClick() {\n      return this.fileInput.trigger('click');\n    }\n\n    onModalShow() {\n      var _this;\n      _this = this;\n      return this.modalCropImg.cropper({\n        viewMode: 1,\n        center: false,\n        aspectRatio: 1,\n        modal: true,\n        scalable: false,\n        rotatable: false,\n        zoomable: true,\n        dragMode: 'move',\n        guides: false,\n        zoomOnTouch: false,\n        zoomOnWheel: false,\n        cropBoxMovable: false,\n        cropBoxResizable: false,\n        toggleDragModeOnDblclick: false,\n        built: function() {\n          var $image, container, cropBoxHeight, cropBoxWidth;\n          $image = $(this);\n          container = $image.cropper('getContainerData');\n          cropBoxWidth = _this.cropBoxWidth;\n          cropBoxHeight = _this.cropBoxHeight;\n          return $image.cropper('setCropBoxData', {\n            width: cropBoxWidth,\n            height: cropBoxHeight,\n            left: (container.width - cropBoxWidth) / 2,\n            top: (container.height - cropBoxHeight) / 2\n          });\n        }\n      });\n    }\n\n    onModalHide() {\n      return this.modalCropImg.attr('src', '').cropper('destroy');\n    }\n\n    onUploadImageBtnClick(e) {\n      e.preventDefault();\n      this.setBlob();\n      this.setPreview();\n      this.modalCrop.modal('hide');\n      return this.fileInput.val('');\n    }\n\n    onActionBtnClick(btn) {\n      var data, result;\n      data = $(btn).data();\n      if (this.modalCropImg.data('cropper') && data.method) {\n        return result = this.modalCropImg.cropper(data.method, data.option);\n      }\n    }\n\n    onFileInputChange(e, input) {\n      return this.readFile(input);\n    }\n\n    readFile(input) {\n      var _this, reader;\n      _this = this;\n      reader = new FileReader;\n      reader.onload = () => {\n        _this.modalCropImg.attr('src', reader.result);\n        return _this.modalCrop.modal('show');\n      };\n      return reader.readAsDataURL(input.files[0]);\n    }\n\n    dataURLtoBlob(dataURL) {\n      var array, binary, i, k, len, v;\n      binary = atob(dataURL.split(',')[1]);\n      array = [];\n      for (k = i = 0, len = binary.length; i < len; k = (i += 1)) {\n        v = binary[k];\n        array.push(binary.charCodeAt(k));\n      }\n      return new Blob([new Uint8Array(array)], {\n        type: 'image/png'\n      });\n    }\n\n    setPreview() {\n      var filename;\n      this.previewImage.attr('src', this.dataURL);\n      filename = this.fileInput.val().replace(FILENAMEREGEX, '');\n      return this.filename.text(filename);\n    }\n\n    setBlob() {\n      this.dataURL = this.modalCropImg.cropper('getCroppedCanvas', {\n        width: 200,\n        height: 200\n      }).toDataURL('image/png');\n      return this.croppedImageBlob = this.dataURLtoBlob(this.dataURL);\n    }\n\n    getBlob() {\n      return this.croppedImageBlob;\n    }\n  }\n\n  $.fn.glCrop = function(opts) {\n    return this.each(function() {\n      return $(this).data('glcrop', new GitLabCrop(this, opts));\n    });\n  };\n})(window.gl || (window.gl = {}));\n\n\n\n// WEBPACK FOOTER //\n// ./profile/gl_crop.js","/* eslint-disable comma-dangle, no-unused-vars, class-methods-use-this, quotes, consistent-return, func-names, prefer-arrow-callback, space-before-function-paren, max-len */\n/* global Flash */\n\n((global) => {\n  class Profile {\n    constructor({ form } = {}) {\n      this.onSubmitForm = this.onSubmitForm.bind(this);\n      this.form = form || $('.edit-user');\n      this.bindEvents();\n      this.initAvatarGlCrop();\n    }\n\n    initAvatarGlCrop() {\n      const cropOpts = {\n        filename: '.js-avatar-filename',\n        previewImage: '.avatar-image .avatar',\n        modalCrop: '.modal-profile-crop',\n        pickImageEl: '.js-choose-user-avatar-button',\n        uploadImageBtn: '.js-upload-user-avatar',\n        modalCropImg: '.modal-profile-crop-image'\n      };\n      this.avatarGlCrop = $('.js-user-avatar-input').glCrop(cropOpts).data('glcrop');\n    }\n\n    bindEvents() {\n      $('.js-preferences-form').on('change.preference', 'input[type=radio]', this.submitForm);\n      $('#user_notification_email').on('change', this.submitForm);\n      $('#user_notified_of_own_activity').on('change', this.submitForm);\n      $('.update-username').on('ajax:before', this.beforeUpdateUsername);\n      $('.update-username').on('ajax:complete', this.afterUpdateUsername);\n      $('.update-notifications').on('ajax:success', this.onUpdateNotifs);\n      this.form.on('submit', this.onSubmitForm);\n    }\n\n    submitForm() {\n      return $(this).parents('form').submit();\n    }\n\n    onSubmitForm(e) {\n      e.preventDefault();\n      return this.saveForm();\n    }\n\n    beforeUpdateUsername() {\n      $('.loading-username', this).removeClass('hidden');\n    }\n\n    afterUpdateUsername() {\n      $('.loading-username', this).addClass('hidden');\n      $('button[type=submit]', this).enable();\n    }\n\n    onUpdateNotifs(e, data) {\n      return data.saved ?\n        new Flash(\"Notification settings saved\", \"notice\") :\n        new Flash(\"Failed to save new settings\", \"alert\");\n    }\n\n    saveForm() {\n      const self = this;\n      const formData = new FormData(this.form[0]);\n      const avatarBlob = this.avatarGlCrop.getBlob();\n\n      if (avatarBlob != null) {\n        formData.append('user[avatar]', avatarBlob, 'avatar.png');\n      }\n\n      return $.ajax({\n        url: this.form.attr('action'),\n        type: this.form.attr('method'),\n        data: formData,\n        dataType: \"json\",\n        processData: false,\n        contentType: false,\n        success: response => new Flash(response.message, 'notice'),\n        error: jqXHR => new Flash(jqXHR.responseJSON.message, 'alert'),\n        complete: () => {\n          window.scrollTo(0, 0);\n          // Enable submit button after requests ends\n          return self.form.find(':input[disabled]').enable();\n        }\n      });\n    }\n  }\n\n  $(function() {\n    $(document).on('input.ssh_key', '#key_key', function() {\n      const $title = $('#key_title');\n      const comment = $(this).val().match(/^\\S+ \\S+ (.+)\\n?$/);\n\n      // Extract the SSH Key title from its comment\n      if (comment && comment.length > 1) {\n        return $title.val(comment[1]).change();\n      }\n    });\n    if (global.utils.getPagePath() === 'profiles') {\n      return new Profile();\n    }\n  });\n})(window.gl || (window.gl = {}));\n\n\n\n// WEBPACK FOOTER //\n// ./profile/profile.js"],"sourceRoot":""}